{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar PeerId = require('peer-id');\n\nvar _require = require('./utils'),\n    ensureMultiaddr = _require.ensureMultiaddr;\n\nvar MultiaddrSet = require('./multiaddr-set');\n\nvar assert = require('assert'); // Peer represents a peer on the IPFS network\n\n\nvar PeerInfo = /*#__PURE__*/function () {\n  function PeerInfo(peerId) {\n    _classCallCheck(this, PeerInfo);\n\n    assert(peerId, 'Missing peerId. Use Peer.create(cb) to create one');\n    this.id = peerId;\n    this.multiaddrs = new MultiaddrSet();\n    this.protocols = new Set();\n    this._connectedMultiaddr = undefined;\n  } // only stores the current multiaddr being used\n\n\n  _createClass(PeerInfo, [{\n    key: \"connect\",\n    value: function connect(ma) {\n      ma = ensureMultiaddr(ma);\n\n      if (!this.multiaddrs.has(ma) && ma.toString() !== \"/ipfs/\".concat(this.id.toB58String())) {\n        throw new Error('can\\'t be connected to missing multiaddr from set');\n      }\n\n      this._connectedMultiaddr = ma;\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this._connectedMultiaddr = undefined;\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this._connectedMultiaddr;\n    }\n  }]);\n\n  return PeerInfo;\n}();\n\nPeerInfo.create = function (peerId, callback) {\n  if (typeof peerId === 'function') {\n    callback = peerId;\n    peerId = null;\n    PeerId.create(function (err, id) {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, new PeerInfo(id));\n    });\n    return;\n  } // Already a PeerId instance\n\n\n  if (typeof peerId.toJSON === 'function') {\n    callback(null, new PeerInfo(peerId));\n  } else {\n    PeerId.createFromJSON(peerId, function (err, id) {\n      return callback(err, new PeerInfo(id));\n    });\n  }\n};\n\nPeerInfo.isPeerInfo = function (peerInfo) {\n  return Boolean(typeof peerInfo === 'object' && peerInfo.id && peerInfo.multiaddrs);\n};\n\nmodule.exports = PeerInfo;","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/peer-info/src/index.js"],"names":["PeerId","require","ensureMultiaddr","MultiaddrSet","assert","PeerInfo","peerId","id","multiaddrs","protocols","Set","_connectedMultiaddr","undefined","ma","has","toString","toB58String","Error","create","callback","err","toJSON","createFromJSON","isPeerInfo","peerInfo","Boolean","module","exports"],"mappings":"AAAA;;;;;;AAEA,IAAMA,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAtB;;eAC4BA,OAAO,CAAC,SAAD,C;IAA3BC,e,YAAAA,e;;AACR,IAAMC,YAAY,GAAGF,OAAO,CAAC,iBAAD,CAA5B;;AACA,IAAMG,MAAM,GAAGH,OAAO,CAAC,QAAD,CAAtB,C,CAEA;;;IACMI,Q;AACJ,oBAAaC,MAAb,EAAqB;AAAA;;AACnBF,IAAAA,MAAM,CAACE,MAAD,EAAS,mDAAT,CAAN;AAEA,SAAKC,EAAL,GAAUD,MAAV;AACA,SAAKE,UAAL,GAAkB,IAAIL,YAAJ,EAAlB;AACA,SAAKM,SAAL,GAAiB,IAAIC,GAAJ,EAAjB;AACA,SAAKC,mBAAL,GAA2BC,SAA3B;AACD,G,CAED;;;;;4BACSC,E,EAAI;AACXA,MAAAA,EAAE,GAAGX,eAAe,CAACW,EAAD,CAApB;;AACA,UAAI,CAAC,KAAKL,UAAL,CAAgBM,GAAhB,CAAoBD,EAApB,CAAD,IAA4BA,EAAE,CAACE,QAAH,uBAA2B,KAAKR,EAAL,CAAQS,WAAR,EAA3B,CAAhC,EAAoF;AAClF,cAAM,IAAIC,KAAJ,CAAU,mDAAV,CAAN;AACD;;AACD,WAAKN,mBAAL,GAA2BE,EAA3B;AACD;;;iCAEa;AACZ,WAAKF,mBAAL,GAA2BC,SAA3B;AACD;;;kCAEc;AACb,aAAO,KAAKD,mBAAZ;AACD;;;;;;AAGHN,QAAQ,CAACa,MAAT,GAAkB,UAACZ,MAAD,EAASa,QAAT,EAAsB;AACtC,MAAI,OAAOb,MAAP,KAAkB,UAAtB,EAAkC;AAChCa,IAAAA,QAAQ,GAAGb,MAAX;AACAA,IAAAA,MAAM,GAAG,IAAT;AAEAN,IAAAA,MAAM,CAACkB,MAAP,CAAc,UAACE,GAAD,EAAMb,EAAN,EAAa;AACzB,UAAIa,GAAJ,EAAS;AACP,eAAOD,QAAQ,CAACC,GAAD,CAAf;AACD;;AAEDD,MAAAA,QAAQ,CAAC,IAAD,EAAO,IAAId,QAAJ,CAAaE,EAAb,CAAP,CAAR;AACD,KAND;AAOA;AACD,GAbqC,CAetC;;;AACA,MAAI,OAAOD,MAAM,CAACe,MAAd,KAAyB,UAA7B,EAAyC;AACvCF,IAAAA,QAAQ,CAAC,IAAD,EAAO,IAAId,QAAJ,CAAaC,MAAb,CAAP,CAAR;AACD,GAFD,MAEO;AACLN,IAAAA,MAAM,CAACsB,cAAP,CAAsBhB,MAAtB,EAA8B,UAACc,GAAD,EAAMb,EAAN;AAAA,aAAaY,QAAQ,CAACC,GAAD,EAAM,IAAIf,QAAJ,CAAaE,EAAb,CAAN,CAArB;AAAA,KAA9B;AACD;AACF,CArBD;;AAuBAF,QAAQ,CAACkB,UAAT,GAAsB,UAACC,QAAD,EAAc;AAClC,SAAOC,OAAO,CAAC,OAAOD,QAAP,KAAoB,QAApB,IACbA,QAAQ,CAACjB,EADI,IAEbiB,QAAQ,CAAChB,UAFG,CAAd;AAGD,CAJD;;AAMAkB,MAAM,CAACC,OAAP,GAAiBtB,QAAjB","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { ensureMultiaddr } = require('./utils')\nconst MultiaddrSet = require('./multiaddr-set')\nconst assert = require('assert')\n\n// Peer represents a peer on the IPFS network\nclass PeerInfo {\n  constructor (peerId) {\n    assert(peerId, 'Missing peerId. Use Peer.create(cb) to create one')\n\n    this.id = peerId\n    this.multiaddrs = new MultiaddrSet()\n    this.protocols = new Set()\n    this._connectedMultiaddr = undefined\n  }\n\n  // only stores the current multiaddr being used\n  connect (ma) {\n    ma = ensureMultiaddr(ma)\n    if (!this.multiaddrs.has(ma) && ma.toString() !== `/ipfs/${this.id.toB58String()}`) {\n      throw new Error('can\\'t be connected to missing multiaddr from set')\n    }\n    this._connectedMultiaddr = ma\n  }\n\n  disconnect () {\n    this._connectedMultiaddr = undefined\n  }\n\n  isConnected () {\n    return this._connectedMultiaddr\n  }\n}\n\nPeerInfo.create = (peerId, callback) => {\n  if (typeof peerId === 'function') {\n    callback = peerId\n    peerId = null\n\n    PeerId.create((err, id) => {\n      if (err) {\n        return callback(err)\n      }\n\n      callback(null, new PeerInfo(id))\n    })\n    return\n  }\n\n  // Already a PeerId instance\n  if (typeof peerId.toJSON === 'function') {\n    callback(null, new PeerInfo(peerId))\n  } else {\n    PeerId.createFromJSON(peerId, (err, id) => callback(err, new PeerInfo(id)))\n  }\n}\n\nPeerInfo.isPeerInfo = (peerInfo) => {\n  return Boolean(typeof peerInfo === 'object' &&\n    peerInfo.id &&\n    peerInfo.multiaddrs)\n}\n\nmodule.exports = PeerInfo\n"]},"metadata":{},"sourceType":"script"}