{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar CID = require('cids');\n\nvar protons = require('protons');\n\nvar proto = protons(require('./dag.proto.js'));\n\nvar DAGLink = require('./dag-link');\n\nvar DAGNode = require('./dag-node');\n\nvar multicodec = require('multicodec');\n\nvar multihashing = require('multihashing-async');\n\nexports = module.exports;\nexports.codec = multicodec.DAG_PB;\nexports.defaultHashAlg = multicodec.SHA2_256;\n/**\n * Calculate the CID of the binary blob.\n *\n * @param {Object} binaryBlob - Encoded IPLD Node\n * @param {Object} [userOptions] - Options to create the CID\n * @param {number} [userOptions.cidVersion=1] - CID version number\n * @param {string} [UserOptions.hashAlg] - Defaults to the defaultHashAlg of the format\n * @returns {Promise.<CID>}\n */\n\nvar cid = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(binaryBlob, userOptions) {\n    var defaultOptions, options, multihash, codecName, cid;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            defaultOptions = {\n              cidVersion: 1,\n              hashAlg: exports.defaultHashAlg\n            };\n            options = Object.assign(defaultOptions, userOptions);\n            _context.next = 4;\n            return multihashing(binaryBlob, options.hashAlg);\n\n          case 4:\n            multihash = _context.sent;\n            codecName = multicodec.print[exports.codec];\n            cid = new CID(options.cidVersion, codecName, multihash);\n            return _context.abrupt(\"return\", cid);\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function cid(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Serialize internal representation into a binary PB block.\n *\n * @param {Object} node - Internal representation of a CBOR block\n * @returns {Buffer} - The encoded binary representation\n */\n\n\nvar serialize = function serialize(node) {\n  var data = node.Data;\n  var links = node.Links || []; // If the node is not an instance of a DAGNode, the link.hash might be a Base58 encoded string; decode it\n\n  if (!DAGNode.isDAGNode(node) && links) {\n    links = links.map(function (link) {\n      return DAGLink.isDAGLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link);\n    });\n  }\n\n  var serialized = proto.PBNode.encode(toProtoBuf({\n    Data: data,\n    Links: links\n  }));\n  return serialized;\n};\n/**\n * Deserialize PB block into the internal representation.\n *\n * @param {Buffer} buffer - Binary representation of a PB block\n * @returns {Object} - An object that conforms to the IPLD Data Model\n */\n\n\nvar deserialize = function deserialize(buffer) {\n  var pbn = proto.PBNode.decode(buffer);\n  var links = pbn.Links.map(function (link) {\n    return new DAGLink(link.Name, link.Tsize, link.Hash);\n  });\n  var data = pbn.Data == null ? Buffer.alloc(0) : pbn.Data;\n  return new DAGNode(data, links, buffer.length);\n};\n\nfunction toProtoBuf(node) {\n  var pbn = {};\n\n  if (node.Data && node.Data.length > 0) {\n    pbn.Data = node.Data;\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization `null !== new Buffer(0)`\n    pbn.Data = null;\n  }\n\n  if (node.Links && node.Links.length > 0) {\n    pbn.Links = node.Links.map(function (link) {\n      return {\n        Hash: link.Hash.buffer,\n        Name: link.Name,\n        Tsize: link.Tsize\n      };\n    });\n  } else {\n    pbn.Links = null;\n  }\n\n  return pbn;\n}\n\nexports.serialize = serialize;\nexports.deserialize = deserialize;\nexports.cid = cid;","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/ipld-dag-pb/src/util.js"],"names":["CID","require","protons","proto","DAGLink","DAGNode","multicodec","multihashing","exports","module","codec","DAG_PB","defaultHashAlg","SHA2_256","cid","binaryBlob","userOptions","defaultOptions","cidVersion","hashAlg","options","Object","assign","multihash","codecName","print","serialize","node","data","Data","links","Links","isDAGNode","map","link","isDAGLink","util","createDagLinkFromB58EncodedHash","serialized","PBNode","encode","toProtoBuf","deserialize","buffer","pbn","decode","Name","Tsize","Hash","Buffer","alloc","length"],"mappings":"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","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst protons = require('protons')\nconst proto = protons(require('./dag.proto.js'))\nconst DAGLink = require('./dag-link')\nconst DAGNode = require('./dag-node')\nconst multicodec = require('multicodec')\nconst multihashing = require('multihashing-async')\n\nexports = module.exports\n\nexports.codec = multicodec.DAG_PB\nexports.defaultHashAlg = multicodec.SHA2_256\n\n/**\n * Calculate the CID of the binary blob.\n *\n * @param {Object} binaryBlob - Encoded IPLD Node\n * @param {Object} [userOptions] - Options to create the CID\n * @param {number} [userOptions.cidVersion=1] - CID version number\n * @param {string} [UserOptions.hashAlg] - Defaults to the defaultHashAlg of the format\n * @returns {Promise.<CID>}\n */\nconst cid = async (binaryBlob, userOptions) => {\n  const defaultOptions = { cidVersion: 1, hashAlg: exports.defaultHashAlg }\n  const options = Object.assign(defaultOptions, userOptions)\n\n  const multihash = await multihashing(binaryBlob, options.hashAlg)\n  const codecName = multicodec.print[exports.codec]\n  const cid = new CID(options.cidVersion, codecName, multihash)\n\n  return cid\n}\n\n/**\n * Serialize internal representation into a binary PB block.\n *\n * @param {Object} node - Internal representation of a CBOR block\n * @returns {Buffer} - The encoded binary representation\n */\nconst serialize = (node) => {\n  let data = node.Data\n  let links = node.Links || []\n\n  // If the node is not an instance of a DAGNode, the link.hash might be a Base58 encoded string; decode it\n  if (!DAGNode.isDAGNode(node) && links) {\n    links = links.map((link) => {\n      return DAGLink.isDAGLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link)\n    })\n  }\n\n  const serialized = proto.PBNode.encode(toProtoBuf({\n    Data: data,\n    Links: links\n  }))\n\n  return serialized\n}\n\n/**\n * Deserialize PB block into the internal representation.\n *\n * @param {Buffer} buffer - Binary representation of a PB block\n * @returns {Object} - An object that conforms to the IPLD Data Model\n */\nconst deserialize = (buffer) => {\n  const pbn = proto.PBNode.decode(buffer)\n\n  const links = pbn.Links.map((link) => {\n    return new DAGLink(link.Name, link.Tsize, link.Hash)\n  })\n\n  const data = pbn.Data == null ? Buffer.alloc(0) : pbn.Data\n\n  return new DAGNode(data, links, buffer.length)\n}\n\nfunction toProtoBuf (node) {\n  const pbn = {}\n\n  if (node.Data && node.Data.length > 0) {\n    pbn.Data = node.Data\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization `null !== new Buffer(0)`\n    pbn.Data = null\n  }\n\n  if (node.Links && node.Links.length > 0) {\n    pbn.Links = node.Links\n      .map((link) => ({\n        Hash: link.Hash.buffer,\n        Name: link.Name,\n        Tsize: link.Tsize\n      }))\n  } else {\n    pbn.Links = null\n  }\n\n  return pbn\n}\n\nexports.serialize = serialize\nexports.deserialize = deserialize\nexports.cid = cid\n"]},"metadata":{},"sourceType":"script"}