{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nvar _require = require('readable-stream'),\n    Duplex = _require.Duplex;\n\nvar PullDuplexStream = /*#__PURE__*/function (_Duplex) {\n  _inherits(PullDuplexStream, _Duplex);\n\n  var _super = _createSuper(PullDuplexStream);\n\n  function PullDuplexStream(source, sink, options) {\n    var _this;\n\n    _classCallCheck(this, PullDuplexStream);\n\n    _this = _super.call(this, options);\n    _this.source = source;\n    _this.drainingSource = false;\n    _this.sink = sink;\n    _this.input = [];\n    _this.writeCallbacks = [];\n    _this.internalSourceCallbacks = [];\n\n    if (_this.sink) {\n      _this.sink(_this._internalSource.bind(_assertThisInitialized(_this)));\n    }\n\n    return _this;\n  }\n\n  _createClass(PullDuplexStream, [{\n    key: \"drainPull\",\n    value: function drainPull() {\n      var self = this;\n      this.drainingSource = true;\n      this.source(null, function next(end, data) {\n        if (end instanceof Error) {\n          return self.emit('error', end);\n        }\n\n        if (end) {\n          return self.push(null);\n        }\n\n        if (self.push(data)) {\n          self.source(null, next);\n        } else {\n          self.drainingSource = false;\n        }\n      });\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      if (this.source && !this.drainingSource) {\n        this.drainPull();\n      }\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, encoding, callback) {\n      if (this.internalSourceCallbacks.length > 0) {\n        this.internalSourceCallbacks.shift()(null, chunk);\n        callback();\n      } else {\n        this.input.push(chunk);\n        this.writeCallbacks.push(callback);\n      }\n    }\n  }, {\n    key: \"_internalSource\",\n    value: function _internalSource(end, cb) {\n      if (end) {\n        if (this.writeCallbacks.length > 0) {\n          // call write callback with error\n          this.writeCallbacks.shift()(end instanceof Error ? end : new Error('Aborted'));\n        }\n\n        return cb(end);\n      }\n\n      if (this.input.length > 0) {\n        cb(null, this.input.shift());\n        this.writeCallbacks.shift()();\n      } else {\n        this.internalSourceCallbacks.push(cb);\n      }\n    }\n  }, {\n    key: \"_final\",\n    value: function _final(callback) {\n      // end the internal source\n      if (this.internalSourceCallbacks.length > 0) {\n        this.internalSourceCallbacks.shift()(true);\n      }\n\n      callback();\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy(err, cb) {\n      // abort the source\n      if (!this._readableState.ended && this.source) {\n        this.source(true, function () {// do nothing\n        });\n      } // propagate error to sink\n\n\n      if (this.internalSourceCallbacks.length > 0) {\n        this.internalSourceCallbacks.shift()(err);\n      }\n\n      cb(err);\n    }\n  }]);\n\n  return PullDuplexStream;\n}(Duplex);\n\nfunction wrapper(source, sink, options) {\n  if (source && typeof source === 'object') {\n    source = source.source;\n    sink = source.sink;\n  }\n\n  return new PullDuplexStream(source, sink, Object.assign({\n    readableObjectMode: true,\n    writableObjectMode: true\n  }, options));\n}\n\nmodule.exports = {\n  duplex: wrapper,\n  readable: function readable(source, options) {\n    return wrapper(source, null, options);\n  },\n  writeable: function writeable(sink, options) {\n    return wrapper(null, sink, options);\n  }\n};","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/pull-to-stream/index.js"],"names":["require","Duplex","PullDuplexStream","source","sink","options","drainingSource","input","writeCallbacks","internalSourceCallbacks","_internalSource","bind","self","next","end","data","Error","emit","push","drainPull","chunk","encoding","callback","length","shift","cb","err","_readableState","ended","wrapper","Object","assign","readableObjectMode","writableObjectMode","module","exports","duplex","readable","writeable"],"mappings":"AAAA;;;;;;;;;;;;eAEmBA,OAAO,CAAC,iBAAD,C;IAAlBC,M,YAAAA,M;;IAEFC,gB;;;;;AACF,4BAAYC,MAAZ,EAAoBC,IAApB,EAA0BC,OAA1B,EAAmC;AAAA;;AAAA;;AAC/B,8BAAMA,OAAN;AACA,UAAKF,MAAL,GAAcA,MAAd;AACA,UAAKG,cAAL,GAAsB,KAAtB;AACA,UAAKF,IAAL,GAAYA,IAAZ;AACA,UAAKG,KAAL,GAAa,EAAb;AACA,UAAKC,cAAL,GAAsB,EAAtB;AACA,UAAKC,uBAAL,GAA+B,EAA/B;;AACA,QAAI,MAAKL,IAAT,EAAe;AACX,YAAKA,IAAL,CAAU,MAAKM,eAAL,CAAqBC,IAArB,+BAAV;AACH;;AAV8B;AAWlC;;;;gCAEW;AACR,UAAMC,IAAI,GAAG,IAAb;AAEA,WAAKN,cAAL,GAAsB,IAAtB;AACA,WAAKH,MAAL,CAAY,IAAZ,EAAkB,SAASU,IAAT,CAAcC,GAAd,EAAmBC,IAAnB,EAAyB;AACvC,YAAID,GAAG,YAAYE,KAAnB,EAA0B;AACtB,iBAAOJ,IAAI,CAACK,IAAL,CAAU,OAAV,EAAmBH,GAAnB,CAAP;AACH;;AAED,YAAIA,GAAJ,EAAS;AACL,iBAAOF,IAAI,CAACM,IAAL,CAAU,IAAV,CAAP;AACH;;AAED,YAAIN,IAAI,CAACM,IAAL,CAAUH,IAAV,CAAJ,EAAqB;AACjBH,UAAAA,IAAI,CAACT,MAAL,CAAY,IAAZ,EAAkBU,IAAlB;AACH,SAFD,MAEO;AACHD,UAAAA,IAAI,CAACN,cAAL,GAAsB,KAAtB;AACH;AACJ,OAdD;AAeH;;;4BAEO;AACJ,UAAI,KAAKH,MAAL,IAAe,CAAC,KAAKG,cAAzB,EAAyC;AACrC,aAAKa,SAAL;AACH;AACJ;;;2BAEMC,K,EAAOC,Q,EAAUC,Q,EAAU;AAC9B,UAAI,KAAKb,uBAAL,CAA6Bc,MAA7B,GAAsC,CAA1C,EAA6C;AACzC,aAAKd,uBAAL,CAA6Be,KAA7B,GAAqC,IAArC,EAA2CJ,KAA3C;AACAE,QAAAA,QAAQ;AACX,OAHD,MAGO;AACH,aAAKf,KAAL,CAAWW,IAAX,CAAgBE,KAAhB;AACA,aAAKZ,cAAL,CAAoBU,IAApB,CAAyBI,QAAzB;AACH;AACJ;;;oCAEeR,G,EAAKW,E,EAAI;AACrB,UAAIX,GAAJ,EAAS;AACL,YAAI,KAAKN,cAAL,CAAoBe,MAApB,GAA6B,CAAjC,EAAoC;AAChC;AACA,eAAKf,cAAL,CAAoBgB,KAApB,GACIV,GAAG,YAAYE,KAAf,GAAuBF,GAAvB,GAA6B,IAAIE,KAAJ,CAAU,SAAV,CADjC;AAGH;;AAED,eAAOS,EAAE,CAACX,GAAD,CAAT;AACH;;AAED,UAAI,KAAKP,KAAL,CAAWgB,MAAX,GAAoB,CAAxB,EAA2B;AACvBE,QAAAA,EAAE,CAAC,IAAD,EAAO,KAAKlB,KAAL,CAAWiB,KAAX,EAAP,CAAF;AACA,aAAKhB,cAAL,CAAoBgB,KAApB;AACH,OAHD,MAGO;AACH,aAAKf,uBAAL,CAA6BS,IAA7B,CAAkCO,EAAlC;AACH;AACJ;;;2BAEMH,Q,EAAU;AACb;AACA,UAAI,KAAKb,uBAAL,CAA6Bc,MAA7B,GAAsC,CAA1C,EAA6C;AACzC,aAAKd,uBAAL,CAA6Be,KAA7B,GAAqC,IAArC;AACH;;AACDF,MAAAA,QAAQ;AACX;;;6BACQI,G,EAAKD,E,EAAI;AACd;AACA,UAAI,CAAC,KAAKE,cAAL,CAAoBC,KAArB,IAA8B,KAAKzB,MAAvC,EAA+C;AAC3C,aAAKA,MAAL,CAAY,IAAZ,EAAkB,YAAM,CACpB;AACH,SAFD;AAGH,OANa,CAQd;;;AACA,UAAI,KAAKM,uBAAL,CAA6Bc,MAA7B,GAAsC,CAA1C,EAA6C;AACzC,aAAKd,uBAAL,CAA6Be,KAA7B,GAAqCE,GAArC;AACH;;AAEDD,MAAAA,EAAE,CAACC,GAAD,CAAF;AACH;;;;EA5F0BzB,M;;AA+F/B,SAAS4B,OAAT,CAAiB1B,MAAjB,EAAyBC,IAAzB,EAA+BC,OAA/B,EAAwC;AACpC,MAAIF,MAAM,IAAI,OAAOA,MAAP,KAAkB,QAAhC,EAA0C;AACtCA,IAAAA,MAAM,GAAGA,MAAM,CAACA,MAAhB;AACAC,IAAAA,IAAI,GAAGD,MAAM,CAACC,IAAd;AACH;;AAED,SAAO,IAAIF,gBAAJ,CACHC,MADG,EAEHC,IAFG,EAGH0B,MAAM,CAACC,MAAP,CACI;AACIC,IAAAA,kBAAkB,EAAE,IADxB;AAEIC,IAAAA,kBAAkB,EAAE;AAFxB,GADJ,EAKI5B,OALJ,CAHG,CAAP;AAWH;;AAED6B,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,MAAM,EAAEP,OADK;AAEbQ,EAAAA,QAAQ,EAAE,kBAAClC,MAAD,EAASE,OAAT;AAAA,WAAqBwB,OAAO,CAAC1B,MAAD,EAAS,IAAT,EAAeE,OAAf,CAA5B;AAAA,GAFG;AAGbiC,EAAAA,SAAS,EAAE,mBAAClC,IAAD,EAAOC,OAAP;AAAA,WAAmBwB,OAAO,CAAC,IAAD,EAAOzB,IAAP,EAAaC,OAAb,CAA1B;AAAA;AAHE,CAAjB","sourcesContent":["'use strict';\n\nconst { Duplex } = require('readable-stream');\n\nclass PullDuplexStream extends Duplex {\n    constructor(source, sink, options) {\n        super(options);\n        this.source = source;\n        this.drainingSource = false;\n        this.sink = sink;\n        this.input = [];\n        this.writeCallbacks = [];\n        this.internalSourceCallbacks = [];\n        if (this.sink) {\n            this.sink(this._internalSource.bind(this));\n        }\n    }\n\n    drainPull() {\n        const self = this;\n\n        this.drainingSource = true;\n        this.source(null, function next(end, data) {\n            if (end instanceof Error) {\n                return self.emit('error', end);\n            }\n\n            if (end) {\n                return self.push(null);\n            }\n\n            if (self.push(data)) {\n                self.source(null, next);\n            } else {\n                self.drainingSource = false;\n            }\n        });\n    }\n\n    _read() {\n        if (this.source && !this.drainingSource) {\n            this.drainPull();\n        }\n    }\n\n    _write(chunk, encoding, callback) {\n        if (this.internalSourceCallbacks.length > 0) {\n            this.internalSourceCallbacks.shift()(null, chunk);\n            callback();\n        } else {\n            this.input.push(chunk);\n            this.writeCallbacks.push(callback);\n        }\n    }\n\n    _internalSource(end, cb) {\n        if (end) {\n            if (this.writeCallbacks.length > 0) {\n                // call write callback with error\n                this.writeCallbacks.shift()(\n                    end instanceof Error ? end : new Error('Aborted')\n                );\n            }\n\n            return cb(end);\n        }\n\n        if (this.input.length > 0) {\n            cb(null, this.input.shift());\n            this.writeCallbacks.shift()();\n        } else {\n            this.internalSourceCallbacks.push(cb);\n        }\n    }\n\n    _final(callback) {\n        // end the internal source\n        if (this.internalSourceCallbacks.length > 0) {\n            this.internalSourceCallbacks.shift()(true);\n        }\n        callback();\n    }\n    _destroy(err, cb) {\n        // abort the source\n        if (!this._readableState.ended && this.source) {\n            this.source(true, () => {\n                // do nothing\n            });\n        }\n\n        // propagate error to sink\n        if (this.internalSourceCallbacks.length > 0) {\n            this.internalSourceCallbacks.shift()(err);\n        }\n\n        cb(err);\n    }\n}\n\nfunction wrapper(source, sink, options) {\n    if (source && typeof source === 'object') {\n        source = source.source;\n        sink = source.sink;\n    }\n\n    return new PullDuplexStream(\n        source,\n        sink,\n        Object.assign(\n            {\n                readableObjectMode: true,\n                writableObjectMode: true\n            },\n            options\n        )\n    );\n}\n\nmodule.exports = {\n    duplex: wrapper,\n    readable: (source, options) => wrapper(source, null, options),\n    writeable: (sink, options) => wrapper(null, sink, options)\n};\n"]},"metadata":{},"sourceType":"script"}