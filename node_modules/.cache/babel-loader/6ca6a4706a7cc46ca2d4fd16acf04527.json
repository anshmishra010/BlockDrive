{"ast":null,"code":"'use strict';\n\nvar secp256k1 = require('secp256k1');\n\nvar multihashing = require('multihashing-async');\n\nvar setImmediate = require('async/setImmediate');\n\nvar HASH_ALGORITHM = 'sha2-256';\n\nmodule.exports = function (randomBytes) {\n  var privateKeyLength = 32;\n\n  function generateKey(callback) {\n    var done = function done(err, res) {\n      return setImmediate(function () {\n        return callback(err, res);\n      });\n    };\n\n    var privateKey;\n\n    do {\n      privateKey = randomBytes(32);\n    } while (!secp256k1.privateKeyVerify(privateKey));\n\n    done(null, privateKey);\n  }\n\n  function hashAndSign(key, msg, callback) {\n    var done = function done(err, res) {\n      return setImmediate(function () {\n        return callback(err, res);\n      });\n    };\n\n    multihashing.digest(msg, HASH_ALGORITHM, function (err, digest) {\n      if (err) {\n        return done(err);\n      }\n\n      try {\n        var sig = secp256k1.sign(digest, key);\n        var sigDER = secp256k1.signatureExport(sig.signature);\n        return done(null, sigDER);\n      } catch (err) {\n        done(err);\n      }\n    });\n  }\n\n  function hashAndVerify(key, sig, msg, callback) {\n    var done = function done(err, res) {\n      return setImmediate(function () {\n        return callback(err, res);\n      });\n    };\n\n    multihashing.digest(msg, HASH_ALGORITHM, function (err, digest) {\n      if (err) {\n        return done(err);\n      }\n\n      try {\n        sig = secp256k1.signatureImport(sig);\n        var valid = secp256k1.verify(digest, sig, key);\n        return done(null, valid);\n      } catch (err) {\n        done(err);\n      }\n    });\n  }\n\n  function compressPublicKey(key) {\n    if (!secp256k1.publicKeyVerify(key)) {\n      throw new Error('Invalid public key');\n    }\n\n    return secp256k1.publicKeyConvert(key, true);\n  }\n\n  function decompressPublicKey(key) {\n    return secp256k1.publicKeyConvert(key, false);\n  }\n\n  function validatePrivateKey(key) {\n    if (!secp256k1.privateKeyVerify(key)) {\n      throw new Error('Invalid private key');\n    }\n  }\n\n  function validatePublicKey(key) {\n    if (!secp256k1.publicKeyVerify(key)) {\n      throw new Error('Invalid public key');\n    }\n  }\n\n  function computePublicKey(privateKey) {\n    validatePrivateKey(privateKey);\n    return secp256k1.publicKeyCreate(privateKey);\n  }\n\n  return {\n    generateKey: generateKey,\n    privateKeyLength: privateKeyLength,\n    hashAndSign: hashAndSign,\n    hashAndVerify: hashAndVerify,\n    compressPublicKey: compressPublicKey,\n    decompressPublicKey: decompressPublicKey,\n    validatePrivateKey: validatePrivateKey,\n    validatePublicKey: validatePublicKey,\n    computePublicKey: computePublicKey\n  };\n};","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/libp2p-crypto-secp256k1/src/crypto.js"],"names":["secp256k1","require","multihashing","setImmediate","HASH_ALGORITHM","module","exports","randomBytes","privateKeyLength","generateKey","callback","done","err","res","privateKey","privateKeyVerify","hashAndSign","key","msg","digest","sig","sign","sigDER","signatureExport","signature","hashAndVerify","signatureImport","valid","verify","compressPublicKey","publicKeyVerify","Error","publicKeyConvert","decompressPublicKey","validatePrivateKey","validatePublicKey","computePublicKey","publicKeyCreate"],"mappings":"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","sourcesContent":["'use strict'\n\nconst secp256k1 = require('secp256k1')\nconst multihashing = require('multihashing-async')\nconst setImmediate = require('async/setImmediate')\n\nconst HASH_ALGORITHM = 'sha2-256'\n\nmodule.exports = (randomBytes) => {\n  const privateKeyLength = 32\n\n  function generateKey (callback) {\n    const done = (err, res) => setImmediate(() => callback(err, res))\n\n    let privateKey\n    do {\n      privateKey = randomBytes(32)\n    } while (!secp256k1.privateKeyVerify(privateKey))\n\n    done(null, privateKey)\n  }\n\n  function hashAndSign (key, msg, callback) {\n    const done = (err, res) => setImmediate(() => callback(err, res))\n\n    multihashing.digest(msg, HASH_ALGORITHM, (err, digest) => {\n      if (err) { return done(err) }\n\n      try {\n        const sig = secp256k1.sign(digest, key)\n        const sigDER = secp256k1.signatureExport(sig.signature)\n        return done(null, sigDER)\n      } catch (err) { done(err) }\n    })\n  }\n\n  function hashAndVerify (key, sig, msg, callback) {\n    const done = (err, res) => setImmediate(() => callback(err, res))\n\n    multihashing.digest(msg, HASH_ALGORITHM, (err, digest) => {\n      if (err) { return done(err) }\n      try {\n        sig = secp256k1.signatureImport(sig)\n        const valid = secp256k1.verify(digest, sig, key)\n        return done(null, valid)\n      } catch (err) { done(err) }\n    })\n  }\n\n  function compressPublicKey (key) {\n    if (!secp256k1.publicKeyVerify(key)) {\n      throw new Error('Invalid public key')\n    }\n    return secp256k1.publicKeyConvert(key, true)\n  }\n\n  function decompressPublicKey (key) {\n    return secp256k1.publicKeyConvert(key, false)\n  }\n\n  function validatePrivateKey (key) {\n    if (!secp256k1.privateKeyVerify(key)) {\n      throw new Error('Invalid private key')\n    }\n  }\n\n  function validatePublicKey (key) {\n    if (!secp256k1.publicKeyVerify(key)) {\n      throw new Error('Invalid public key')\n    }\n  }\n\n  function computePublicKey (privateKey) {\n    validatePrivateKey(privateKey)\n    return secp256k1.publicKeyCreate(privateKey)\n  }\n\n  return {\n    generateKey: generateKey,\n    privateKeyLength: privateKeyLength,\n    hashAndSign: hashAndSign,\n    hashAndVerify: hashAndVerify,\n    compressPublicKey: compressPublicKey,\n    decompressPublicKey: decompressPublicKey,\n    validatePrivateKey: validatePrivateKey,\n    validatePublicKey: validatePublicKey,\n    computePublicKey: computePublicKey\n  }\n}\n"]},"metadata":{},"sourceType":"script"}