{"ast":null,"code":"var util = require('util');\n\nvar bl = require('bl');\n\nvar headers = require('./headers');\n\nvar Writable = require('readable-stream').Writable;\n\nvar PassThrough = require('readable-stream').PassThrough;\n\nvar noop = function noop() {};\n\nvar overflow = function overflow(size) {\n  size &= 511;\n  return size && 512 - size;\n};\n\nvar emptyStream = function emptyStream(self, offset) {\n  var s = new Source(self, offset);\n  s.end();\n  return s;\n};\n\nvar mixinPax = function mixinPax(header, pax) {\n  if (pax.path) header.name = pax.path;\n  if (pax.linkpath) header.linkname = pax.linkpath;\n  if (pax.size) header.size = parseInt(pax.size, 10);\n  header.pax = pax;\n  return header;\n};\n\nvar Source = function Source(self, offset) {\n  this._parent = self;\n  this.offset = offset;\n  PassThrough.call(this, {\n    autoDestroy: false\n  });\n};\n\nutil.inherits(Source, PassThrough);\n\nSource.prototype.destroy = function (err) {\n  this._parent.destroy(err);\n};\n\nvar Extract = function Extract(opts) {\n  if (!(this instanceof Extract)) return new Extract(opts);\n  Writable.call(this, opts);\n  opts = opts || {};\n  this._offset = 0;\n  this._buffer = bl();\n  this._missing = 0;\n  this._partial = false;\n  this._onparse = noop;\n  this._header = null;\n  this._stream = null;\n  this._overflow = null;\n  this._cb = null;\n  this._locked = false;\n  this._destroyed = false;\n  this._pax = null;\n  this._paxGlobal = null;\n  this._gnuLongPath = null;\n  this._gnuLongLinkPath = null;\n  var self = this;\n  var b = self._buffer;\n\n  var oncontinue = function oncontinue() {\n    self._continue();\n  };\n\n  var onunlock = function onunlock(err) {\n    self._locked = false;\n    if (err) return self.destroy(err);\n    if (!self._stream) oncontinue();\n  };\n\n  var onstreamend = function onstreamend() {\n    self._stream = null;\n    var drain = overflow(self._header.size);\n    if (drain) self._parse(drain, ondrain);else self._parse(512, onheader);\n    if (!self._locked) oncontinue();\n  };\n\n  var ondrain = function ondrain() {\n    self._buffer.consume(overflow(self._header.size));\n\n    self._parse(512, onheader);\n\n    oncontinue();\n  };\n\n  var onpaxglobalheader = function onpaxglobalheader() {\n    var size = self._header.size;\n    self._paxGlobal = headers.decodePax(b.slice(0, size));\n    b.consume(size);\n    onstreamend();\n  };\n\n  var onpaxheader = function onpaxheader() {\n    var size = self._header.size;\n    self._pax = headers.decodePax(b.slice(0, size));\n    if (self._paxGlobal) self._pax = Object.assign({}, self._paxGlobal, self._pax);\n    b.consume(size);\n    onstreamend();\n  };\n\n  var ongnulongpath = function ongnulongpath() {\n    var size = self._header.size;\n    this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);\n    b.consume(size);\n    onstreamend();\n  };\n\n  var ongnulonglinkpath = function ongnulonglinkpath() {\n    var size = self._header.size;\n    this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);\n    b.consume(size);\n    onstreamend();\n  };\n\n  var onheader = function onheader() {\n    var offset = self._offset;\n    var header;\n\n    try {\n      header = self._header = headers.decode(b.slice(0, 512), opts.filenameEncoding);\n    } catch (err) {\n      self.emit('error', err);\n    }\n\n    b.consume(512);\n\n    if (!header) {\n      self._parse(512, onheader);\n\n      oncontinue();\n      return;\n    }\n\n    if (header.type === 'gnu-long-path') {\n      self._parse(header.size, ongnulongpath);\n\n      oncontinue();\n      return;\n    }\n\n    if (header.type === 'gnu-long-link-path') {\n      self._parse(header.size, ongnulonglinkpath);\n\n      oncontinue();\n      return;\n    }\n\n    if (header.type === 'pax-global-header') {\n      self._parse(header.size, onpaxglobalheader);\n\n      oncontinue();\n      return;\n    }\n\n    if (header.type === 'pax-header') {\n      self._parse(header.size, onpaxheader);\n\n      oncontinue();\n      return;\n    }\n\n    if (self._gnuLongPath) {\n      header.name = self._gnuLongPath;\n      self._gnuLongPath = null;\n    }\n\n    if (self._gnuLongLinkPath) {\n      header.linkname = self._gnuLongLinkPath;\n      self._gnuLongLinkPath = null;\n    }\n\n    if (self._pax) {\n      self._header = header = mixinPax(header, self._pax);\n      self._pax = null;\n    }\n\n    self._locked = true;\n\n    if (!header.size || header.type === 'directory') {\n      self._parse(512, onheader);\n\n      self.emit('entry', header, emptyStream(self, offset), onunlock);\n      return;\n    }\n\n    self._stream = new Source(self, offset);\n    self.emit('entry', header, self._stream, onunlock);\n\n    self._parse(header.size, onstreamend);\n\n    oncontinue();\n  };\n\n  this._onheader = onheader;\n\n  this._parse(512, onheader);\n};\n\nutil.inherits(Extract, Writable);\n\nExtract.prototype.destroy = function (err) {\n  if (this._destroyed) return;\n  this._destroyed = true;\n  if (err) this.emit('error', err);\n  this.emit('close');\n  if (this._stream) this._stream.emit('close');\n};\n\nExtract.prototype._parse = function (size, onparse) {\n  if (this._destroyed) return;\n  this._offset += size;\n  this._missing = size;\n  if (onparse === this._onheader) this._partial = false;\n  this._onparse = onparse;\n};\n\nExtract.prototype._continue = function () {\n  if (this._destroyed) return;\n  var cb = this._cb;\n  this._cb = noop;\n  if (this._overflow) this._write(this._overflow, undefined, cb);else cb();\n};\n\nExtract.prototype._write = function (data, enc, cb) {\n  if (this._destroyed) return;\n  var s = this._stream;\n  var b = this._buffer;\n  var missing = this._missing;\n  if (data.length) this._partial = true; // we do not reach end-of-chunk now. just forward it\n\n  if (data.length < missing) {\n    this._missing -= data.length;\n    this._overflow = null;\n    if (s) return s.write(data, cb);\n    b.append(data);\n    return cb();\n  } // end-of-chunk. the parser should call cb.\n\n\n  this._cb = cb;\n  this._missing = 0;\n  var overflow = null;\n\n  if (data.length > missing) {\n    overflow = data.slice(missing);\n    data = data.slice(0, missing);\n  }\n\n  if (s) s.end(data);else b.append(data);\n  this._overflow = overflow;\n\n  this._onparse();\n};\n\nExtract.prototype._final = function (cb) {\n  if (this._partial) return this.destroy(new Error('Unexpected end of data'));\n  cb();\n};\n\nmodule.exports = Extract;","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/tar-stream/extract.js"],"names":["util","require","bl","headers","Writable","PassThrough","noop","overflow","size","emptyStream","self","offset","s","Source","end","mixinPax","header","pax","path","name","linkpath","linkname","parseInt","_parent","call","autoDestroy","inherits","prototype","destroy","err","Extract","opts","_offset","_buffer","_missing","_partial","_onparse","_header","_stream","_overflow","_cb","_locked","_destroyed","_pax","_paxGlobal","_gnuLongPath","_gnuLongLinkPath","b","oncontinue","_continue","onunlock","onstreamend","drain","_parse","ondrain","onheader","consume","onpaxglobalheader","decodePax","slice","onpaxheader","Object","assign","ongnulongpath","decodeLongPath","filenameEncoding","ongnulonglinkpath","decode","emit","type","_onheader","onparse","cb","_write","undefined","data","enc","missing","length","write","append","_final","Error","module","exports"],"mappings":"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","sourcesContent":["var util = require('util')\nvar bl = require('bl')\nvar headers = require('./headers')\n\nvar Writable = require('readable-stream').Writable\nvar PassThrough = require('readable-stream').PassThrough\n\nvar noop = function () {}\n\nvar overflow = function (size) {\n  size &= 511\n  return size && 512 - size\n}\n\nvar emptyStream = function (self, offset) {\n  var s = new Source(self, offset)\n  s.end()\n  return s\n}\n\nvar mixinPax = function (header, pax) {\n  if (pax.path) header.name = pax.path\n  if (pax.linkpath) header.linkname = pax.linkpath\n  if (pax.size) header.size = parseInt(pax.size, 10)\n  header.pax = pax\n  return header\n}\n\nvar Source = function (self, offset) {\n  this._parent = self\n  this.offset = offset\n  PassThrough.call(this, { autoDestroy: false })\n}\n\nutil.inherits(Source, PassThrough)\n\nSource.prototype.destroy = function (err) {\n  this._parent.destroy(err)\n}\n\nvar Extract = function (opts) {\n  if (!(this instanceof Extract)) return new Extract(opts)\n  Writable.call(this, opts)\n\n  opts = opts || {}\n\n  this._offset = 0\n  this._buffer = bl()\n  this._missing = 0\n  this._partial = false\n  this._onparse = noop\n  this._header = null\n  this._stream = null\n  this._overflow = null\n  this._cb = null\n  this._locked = false\n  this._destroyed = false\n  this._pax = null\n  this._paxGlobal = null\n  this._gnuLongPath = null\n  this._gnuLongLinkPath = null\n\n  var self = this\n  var b = self._buffer\n\n  var oncontinue = function () {\n    self._continue()\n  }\n\n  var onunlock = function (err) {\n    self._locked = false\n    if (err) return self.destroy(err)\n    if (!self._stream) oncontinue()\n  }\n\n  var onstreamend = function () {\n    self._stream = null\n    var drain = overflow(self._header.size)\n    if (drain) self._parse(drain, ondrain)\n    else self._parse(512, onheader)\n    if (!self._locked) oncontinue()\n  }\n\n  var ondrain = function () {\n    self._buffer.consume(overflow(self._header.size))\n    self._parse(512, onheader)\n    oncontinue()\n  }\n\n  var onpaxglobalheader = function () {\n    var size = self._header.size\n    self._paxGlobal = headers.decodePax(b.slice(0, size))\n    b.consume(size)\n    onstreamend()\n  }\n\n  var onpaxheader = function () {\n    var size = self._header.size\n    self._pax = headers.decodePax(b.slice(0, size))\n    if (self._paxGlobal) self._pax = Object.assign({}, self._paxGlobal, self._pax)\n    b.consume(size)\n    onstreamend()\n  }\n\n  var ongnulongpath = function () {\n    var size = self._header.size\n    this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding)\n    b.consume(size)\n    onstreamend()\n  }\n\n  var ongnulonglinkpath = function () {\n    var size = self._header.size\n    this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding)\n    b.consume(size)\n    onstreamend()\n  }\n\n  var onheader = function () {\n    var offset = self._offset\n    var header\n    try {\n      header = self._header = headers.decode(b.slice(0, 512), opts.filenameEncoding)\n    } catch (err) {\n      self.emit('error', err)\n    }\n    b.consume(512)\n\n    if (!header) {\n      self._parse(512, onheader)\n      oncontinue()\n      return\n    }\n    if (header.type === 'gnu-long-path') {\n      self._parse(header.size, ongnulongpath)\n      oncontinue()\n      return\n    }\n    if (header.type === 'gnu-long-link-path') {\n      self._parse(header.size, ongnulonglinkpath)\n      oncontinue()\n      return\n    }\n    if (header.type === 'pax-global-header') {\n      self._parse(header.size, onpaxglobalheader)\n      oncontinue()\n      return\n    }\n    if (header.type === 'pax-header') {\n      self._parse(header.size, onpaxheader)\n      oncontinue()\n      return\n    }\n\n    if (self._gnuLongPath) {\n      header.name = self._gnuLongPath\n      self._gnuLongPath = null\n    }\n\n    if (self._gnuLongLinkPath) {\n      header.linkname = self._gnuLongLinkPath\n      self._gnuLongLinkPath = null\n    }\n\n    if (self._pax) {\n      self._header = header = mixinPax(header, self._pax)\n      self._pax = null\n    }\n\n    self._locked = true\n\n    if (!header.size || header.type === 'directory') {\n      self._parse(512, onheader)\n      self.emit('entry', header, emptyStream(self, offset), onunlock)\n      return\n    }\n\n    self._stream = new Source(self, offset)\n\n    self.emit('entry', header, self._stream, onunlock)\n    self._parse(header.size, onstreamend)\n    oncontinue()\n  }\n\n  this._onheader = onheader\n  this._parse(512, onheader)\n}\n\nutil.inherits(Extract, Writable)\n\nExtract.prototype.destroy = function (err) {\n  if (this._destroyed) return\n  this._destroyed = true\n\n  if (err) this.emit('error', err)\n  this.emit('close')\n  if (this._stream) this._stream.emit('close')\n}\n\nExtract.prototype._parse = function (size, onparse) {\n  if (this._destroyed) return\n  this._offset += size\n  this._missing = size\n  if (onparse === this._onheader) this._partial = false\n  this._onparse = onparse\n}\n\nExtract.prototype._continue = function () {\n  if (this._destroyed) return\n  var cb = this._cb\n  this._cb = noop\n  if (this._overflow) this._write(this._overflow, undefined, cb)\n  else cb()\n}\n\nExtract.prototype._write = function (data, enc, cb) {\n  if (this._destroyed) return\n\n  var s = this._stream\n  var b = this._buffer\n  var missing = this._missing\n  if (data.length) this._partial = true\n\n  // we do not reach end-of-chunk now. just forward it\n\n  if (data.length < missing) {\n    this._missing -= data.length\n    this._overflow = null\n    if (s) return s.write(data, cb)\n    b.append(data)\n    return cb()\n  }\n\n  // end-of-chunk. the parser should call cb.\n\n  this._cb = cb\n  this._missing = 0\n\n  var overflow = null\n  if (data.length > missing) {\n    overflow = data.slice(missing)\n    data = data.slice(0, missing)\n  }\n\n  if (s) s.end(data)\n  else b.append(data)\n\n  this._overflow = overflow\n  this._onparse()\n}\n\nExtract.prototype._final = function (cb) {\n  if (this._partial) return this.destroy(new Error('Unexpected end of data'))\n  cb()\n}\n\nmodule.exports = Extract\n"]},"metadata":{},"sourceType":"script"}