{"ast":null,"code":"// Blake2B in pure Javascript\n// Adapted from the reference implementation in RFC7693\n// Ported to Javascript by DC - https://github.com/dcposch\nvar util = require('./util'); // 64-bit unsigned addition\n// Sets v[a,a+1] += v[b,b+1]\n// v should be a Uint32Array\n\n\nfunction ADD64AA(v, a, b) {\n  var o0 = v[a] + v[b];\n  var o1 = v[a + 1] + v[b + 1];\n\n  if (o0 >= 0x100000000) {\n    o1++;\n  }\n\n  v[a] = o0;\n  v[a + 1] = o1;\n} // 64-bit unsigned addition\n// Sets v[a,a+1] += b\n// b0 is the low 32 bits of b, b1 represents the high 32 bits\n\n\nfunction ADD64AC(v, a, b0, b1) {\n  var o0 = v[a] + b0;\n\n  if (b0 < 0) {\n    o0 += 0x100000000;\n  }\n\n  var o1 = v[a + 1] + b1;\n\n  if (o0 >= 0x100000000) {\n    o1++;\n  }\n\n  v[a] = o0;\n  v[a + 1] = o1;\n} // Little-endian byte access\n\n\nfunction B2B_GET32(arr, i) {\n  return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;\n} // G Mixing function\n// The ROTRs are inlined for speed\n\n\nfunction B2B_G(a, b, c, d, ix, iy) {\n  var x0 = m[ix];\n  var x1 = m[ix + 1];\n  var y0 = m[iy];\n  var y1 = m[iy + 1];\n  ADD64AA(v, a, b); // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s\n\n  ADD64AC(v, a, x0, x1); // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits\n\n  var xor0 = v[d] ^ v[a];\n  var xor1 = v[d + 1] ^ v[a + 1];\n  v[d] = xor1;\n  v[d + 1] = xor0;\n  ADD64AA(v, c, d); // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits\n\n  xor0 = v[b] ^ v[c];\n  xor1 = v[b + 1] ^ v[c + 1];\n  v[b] = xor0 >>> 24 ^ xor1 << 8;\n  v[b + 1] = xor1 >>> 24 ^ xor0 << 8;\n  ADD64AA(v, a, b);\n  ADD64AC(v, a, y0, y1); // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits\n\n  xor0 = v[d] ^ v[a];\n  xor1 = v[d + 1] ^ v[a + 1];\n  v[d] = xor0 >>> 16 ^ xor1 << 16;\n  v[d + 1] = xor1 >>> 16 ^ xor0 << 16;\n  ADD64AA(v, c, d); // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits\n\n  xor0 = v[b] ^ v[c];\n  xor1 = v[b + 1] ^ v[c + 1];\n  v[b] = xor1 >>> 31 ^ xor0 << 1;\n  v[b + 1] = xor0 >>> 31 ^ xor1 << 1;\n} // Initialization Vector\n\n\nvar BLAKE2B_IV32 = new Uint32Array([0xF3BCC908, 0x6A09E667, 0x84CAA73B, 0xBB67AE85, 0xFE94F82B, 0x3C6EF372, 0x5F1D36F1, 0xA54FF53A, 0xADE682D1, 0x510E527F, 0x2B3E6C1F, 0x9B05688C, 0xFB41BD6B, 0x1F83D9AB, 0x137E2179, 0x5BE0CD19]);\nvar SIGMA8 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3]; // These are offsets into a uint64 buffer.\n// Multiply them all by 2 to make them offsets into a uint32 buffer,\n// because this is Javascript and we don't have uint64s\n\nvar SIGMA82 = new Uint8Array(SIGMA8.map(function (x) {\n  return x * 2;\n})); // Compression function. 'last' flag indicates last block.\n// Note we're representing 16 uint64s as 32 uint32s\n\nvar v = new Uint32Array(32);\nvar m = new Uint32Array(32);\n\nfunction blake2bCompress(ctx, last) {\n  var i = 0; // init work variables\n\n  for (i = 0; i < 16; i++) {\n    v[i] = ctx.h[i];\n    v[i + 16] = BLAKE2B_IV32[i];\n  } // low 64 bits of offset\n\n\n  v[24] = v[24] ^ ctx.t;\n  v[25] = v[25] ^ ctx.t / 0x100000000; // high 64 bits not supported, offset may not be higher than 2**53-1\n  // last block flag set ?\n\n  if (last) {\n    v[28] = ~v[28];\n    v[29] = ~v[29];\n  } // get little-endian words\n\n\n  for (i = 0; i < 32; i++) {\n    m[i] = B2B_GET32(ctx.b, 4 * i);\n  } // twelve rounds of mixing\n  // uncomment the DebugPrint calls to log the computation\n  // and match the RFC sample documentation\n  // util.debugPrint('          m[16]', m, 64)\n\n\n  for (i = 0; i < 12; i++) {\n    // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)\n    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);\n    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);\n    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);\n    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);\n    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);\n    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);\n    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);\n    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);\n  } // util.debugPrint('   (i=12) v[16]', v, 64)\n\n\n  for (i = 0; i < 16; i++) {\n    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];\n  } // util.debugPrint('h[8]', ctx.h, 64)\n\n} // Creates a BLAKE2b hashing context\n// Requires an output length between 1 and 64 bytes\n// Takes an optional Uint8Array key\n\n\nfunction blake2bInit(outlen, key) {\n  if (outlen === 0 || outlen > 64) {\n    throw new Error('Illegal output length, expected 0 < length <= 64');\n  }\n\n  if (key && key.length > 64) {\n    throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64');\n  } // state, 'param block'\n\n\n  var ctx = {\n    b: new Uint8Array(128),\n    h: new Uint32Array(16),\n    t: 0,\n    // input count\n    c: 0,\n    // pointer within buffer\n    outlen: outlen // output length in bytes\n\n  }; // initialize hash state\n\n  for (var i = 0; i < 16; i++) {\n    ctx.h[i] = BLAKE2B_IV32[i];\n  }\n\n  var keylen = key ? key.length : 0;\n  ctx.h[0] ^= 0x01010000 ^ keylen << 8 ^ outlen; // key the hash, if applicable\n\n  if (key) {\n    blake2bUpdate(ctx, key); // at the end\n\n    ctx.c = 128;\n  }\n\n  return ctx;\n} // Updates a BLAKE2b streaming hash\n// Requires hash context and Uint8Array (byte array)\n\n\nfunction blake2bUpdate(ctx, input) {\n  for (var i = 0; i < input.length; i++) {\n    if (ctx.c === 128) {\n      // buffer full ?\n      ctx.t += ctx.c; // add counters\n\n      blake2bCompress(ctx, false); // compress (not last)\n\n      ctx.c = 0; // counter to zero\n    }\n\n    ctx.b[ctx.c++] = input[i];\n  }\n} // Completes a BLAKE2b streaming hash\n// Returns a Uint8Array containing the message digest\n\n\nfunction blake2bFinal(ctx) {\n  ctx.t += ctx.c; // mark last block offset\n\n  while (ctx.c < 128) {\n    // fill up with zeros\n    ctx.b[ctx.c++] = 0;\n  }\n\n  blake2bCompress(ctx, true); // final block flag = 1\n  // little endian convert and store\n\n  var out = new Uint8Array(ctx.outlen);\n\n  for (var i = 0; i < ctx.outlen; i++) {\n    out[i] = ctx.h[i >> 2] >> 8 * (i & 3);\n  }\n\n  return out;\n} // Computes the BLAKE2B hash of a string or byte array, and returns a Uint8Array\n//\n// Returns a n-byte Uint8Array\n//\n// Parameters:\n// - input - the input bytes, as a string, Buffer or Uint8Array\n// - key - optional key Uint8Array, up to 64 bytes\n// - outlen - optional output length in bytes, default 64\n\n\nfunction blake2b(input, key, outlen) {\n  // preprocess inputs\n  outlen = outlen || 64;\n  input = util.normalizeInput(input); // do the math\n\n  var ctx = blake2bInit(outlen, key);\n  blake2bUpdate(ctx, input);\n  return blake2bFinal(ctx);\n} // Computes the BLAKE2B hash of a string or byte array\n//\n// Returns an n-byte hash in hex, all lowercase\n//\n// Parameters:\n// - input - the input bytes, as a string, Buffer, or Uint8Array\n// - key - optional key Uint8Array, up to 64 bytes\n// - outlen - optional output length in bytes, default 64\n\n\nfunction blake2bHex(input, key, outlen) {\n  var output = blake2b(input, key, outlen);\n  return util.toHex(output);\n}\n\nmodule.exports = {\n  blake2b: blake2b,\n  blake2bHex: blake2bHex,\n  blake2bInit: blake2bInit,\n  blake2bUpdate: blake2bUpdate,\n  blake2bFinal: blake2bFinal\n};","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/blakejs/blake2b.js"],"names":["util","require","ADD64AA","v","a","b","o0","o1","ADD64AC","b0","b1","B2B_GET32","arr","i","B2B_G","c","d","ix","iy","x0","m","x1","y0","y1","xor0","xor1","BLAKE2B_IV32","Uint32Array","SIGMA8","SIGMA82","Uint8Array","map","x","blake2bCompress","ctx","last","h","t","blake2bInit","outlen","key","Error","length","keylen","blake2bUpdate","input","blake2bFinal","out","blake2b","normalizeInput","blake2bHex","output","toHex","module","exports"],"mappings":"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","sourcesContent":["// Blake2B in pure Javascript\n// Adapted from the reference implementation in RFC7693\n// Ported to Javascript by DC - https://github.com/dcposch\n\nvar util = require('./util')\n\n// 64-bit unsigned addition\n// Sets v[a,a+1] += v[b,b+1]\n// v should be a Uint32Array\nfunction ADD64AA (v, a, b) {\n  var o0 = v[a] + v[b]\n  var o1 = v[a + 1] + v[b + 1]\n  if (o0 >= 0x100000000) {\n    o1++\n  }\n  v[a] = o0\n  v[a + 1] = o1\n}\n\n// 64-bit unsigned addition\n// Sets v[a,a+1] += b\n// b0 is the low 32 bits of b, b1 represents the high 32 bits\nfunction ADD64AC (v, a, b0, b1) {\n  var o0 = v[a] + b0\n  if (b0 < 0) {\n    o0 += 0x100000000\n  }\n  var o1 = v[a + 1] + b1\n  if (o0 >= 0x100000000) {\n    o1++\n  }\n  v[a] = o0\n  v[a + 1] = o1\n}\n\n// Little-endian byte access\nfunction B2B_GET32 (arr, i) {\n  return (arr[i] ^\n  (arr[i + 1] << 8) ^\n  (arr[i + 2] << 16) ^\n  (arr[i + 3] << 24))\n}\n\n// G Mixing function\n// The ROTRs are inlined for speed\nfunction B2B_G (a, b, c, d, ix, iy) {\n  var x0 = m[ix]\n  var x1 = m[ix + 1]\n  var y0 = m[iy]\n  var y1 = m[iy + 1]\n\n  ADD64AA(v, a, b) // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s\n  ADD64AC(v, a, x0, x1) // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits\n\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits\n  var xor0 = v[d] ^ v[a]\n  var xor1 = v[d + 1] ^ v[a + 1]\n  v[d] = xor1\n  v[d + 1] = xor0\n\n  ADD64AA(v, c, d)\n\n  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits\n  xor0 = v[b] ^ v[c]\n  xor1 = v[b + 1] ^ v[c + 1]\n  v[b] = (xor0 >>> 24) ^ (xor1 << 8)\n  v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)\n\n  ADD64AA(v, a, b)\n  ADD64AC(v, a, y0, y1)\n\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits\n  xor0 = v[d] ^ v[a]\n  xor1 = v[d + 1] ^ v[a + 1]\n  v[d] = (xor0 >>> 16) ^ (xor1 << 16)\n  v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)\n\n  ADD64AA(v, c, d)\n\n  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits\n  xor0 = v[b] ^ v[c]\n  xor1 = v[b + 1] ^ v[c + 1]\n  v[b] = (xor1 >>> 31) ^ (xor0 << 1)\n  v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)\n}\n\n// Initialization Vector\nvar BLAKE2B_IV32 = new Uint32Array([\n  0xF3BCC908, 0x6A09E667, 0x84CAA73B, 0xBB67AE85,\n  0xFE94F82B, 0x3C6EF372, 0x5F1D36F1, 0xA54FF53A,\n  0xADE682D1, 0x510E527F, 0x2B3E6C1F, 0x9B05688C,\n  0xFB41BD6B, 0x1F83D9AB, 0x137E2179, 0x5BE0CD19\n])\n\nvar SIGMA8 = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3\n]\n\n// These are offsets into a uint64 buffer.\n// Multiply them all by 2 to make them offsets into a uint32 buffer,\n// because this is Javascript and we don't have uint64s\nvar SIGMA82 = new Uint8Array(SIGMA8.map(function (x) { return x * 2 }))\n\n// Compression function. 'last' flag indicates last block.\n// Note we're representing 16 uint64s as 32 uint32s\nvar v = new Uint32Array(32)\nvar m = new Uint32Array(32)\nfunction blake2bCompress (ctx, last) {\n  var i = 0\n\n  // init work variables\n  for (i = 0; i < 16; i++) {\n    v[i] = ctx.h[i]\n    v[i + 16] = BLAKE2B_IV32[i]\n  }\n\n  // low 64 bits of offset\n  v[24] = v[24] ^ ctx.t\n  v[25] = v[25] ^ (ctx.t / 0x100000000)\n  // high 64 bits not supported, offset may not be higher than 2**53-1\n\n  // last block flag set ?\n  if (last) {\n    v[28] = ~v[28]\n    v[29] = ~v[29]\n  }\n\n  // get little-endian words\n  for (i = 0; i < 32; i++) {\n    m[i] = B2B_GET32(ctx.b, 4 * i)\n  }\n\n  // twelve rounds of mixing\n  // uncomment the DebugPrint calls to log the computation\n  // and match the RFC sample documentation\n  // util.debugPrint('          m[16]', m, 64)\n  for (i = 0; i < 12; i++) {\n    // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)\n    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1])\n    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3])\n    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5])\n    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7])\n    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9])\n    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11])\n    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13])\n    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15])\n  }\n  // util.debugPrint('   (i=12) v[16]', v, 64)\n\n  for (i = 0; i < 16; i++) {\n    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16]\n  }\n  // util.debugPrint('h[8]', ctx.h, 64)\n}\n\n// Creates a BLAKE2b hashing context\n// Requires an output length between 1 and 64 bytes\n// Takes an optional Uint8Array key\nfunction blake2bInit (outlen, key) {\n  if (outlen === 0 || outlen > 64) {\n    throw new Error('Illegal output length, expected 0 < length <= 64')\n  }\n  if (key && key.length > 64) {\n    throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64')\n  }\n\n  // state, 'param block'\n  var ctx = {\n    b: new Uint8Array(128),\n    h: new Uint32Array(16),\n    t: 0, // input count\n    c: 0, // pointer within buffer\n    outlen: outlen // output length in bytes\n  }\n\n  // initialize hash state\n  for (var i = 0; i < 16; i++) {\n    ctx.h[i] = BLAKE2B_IV32[i]\n  }\n  var keylen = key ? key.length : 0\n  ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen\n\n  // key the hash, if applicable\n  if (key) {\n    blake2bUpdate(ctx, key)\n    // at the end\n    ctx.c = 128\n  }\n\n  return ctx\n}\n\n// Updates a BLAKE2b streaming hash\n// Requires hash context and Uint8Array (byte array)\nfunction blake2bUpdate (ctx, input) {\n  for (var i = 0; i < input.length; i++) {\n    if (ctx.c === 128) { // buffer full ?\n      ctx.t += ctx.c // add counters\n      blake2bCompress(ctx, false) // compress (not last)\n      ctx.c = 0 // counter to zero\n    }\n    ctx.b[ctx.c++] = input[i]\n  }\n}\n\n// Completes a BLAKE2b streaming hash\n// Returns a Uint8Array containing the message digest\nfunction blake2bFinal (ctx) {\n  ctx.t += ctx.c // mark last block offset\n\n  while (ctx.c < 128) { // fill up with zeros\n    ctx.b[ctx.c++] = 0\n  }\n  blake2bCompress(ctx, true) // final block flag = 1\n\n  // little endian convert and store\n  var out = new Uint8Array(ctx.outlen)\n  for (var i = 0; i < ctx.outlen; i++) {\n    out[i] = ctx.h[i >> 2] >> (8 * (i & 3))\n  }\n  return out\n}\n\n// Computes the BLAKE2B hash of a string or byte array, and returns a Uint8Array\n//\n// Returns a n-byte Uint8Array\n//\n// Parameters:\n// - input - the input bytes, as a string, Buffer or Uint8Array\n// - key - optional key Uint8Array, up to 64 bytes\n// - outlen - optional output length in bytes, default 64\nfunction blake2b (input, key, outlen) {\n  // preprocess inputs\n  outlen = outlen || 64\n  input = util.normalizeInput(input)\n\n  // do the math\n  var ctx = blake2bInit(outlen, key)\n  blake2bUpdate(ctx, input)\n  return blake2bFinal(ctx)\n}\n\n// Computes the BLAKE2B hash of a string or byte array\n//\n// Returns an n-byte hash in hex, all lowercase\n//\n// Parameters:\n// - input - the input bytes, as a string, Buffer, or Uint8Array\n// - key - optional key Uint8Array, up to 64 bytes\n// - outlen - optional output length in bytes, default 64\nfunction blake2bHex (input, key, outlen) {\n  var output = blake2b(input, key, outlen)\n  return util.toHex(output)\n}\n\nmodule.exports = {\n  blake2b: blake2b,\n  blake2bHex: blake2bHex,\n  blake2bInit: blake2bInit,\n  blake2bUpdate: blake2bUpdate,\n  blake2bFinal: blake2bFinal\n}\n"]},"metadata":{},"sourceType":"script"}