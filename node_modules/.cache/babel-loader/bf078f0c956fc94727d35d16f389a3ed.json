{"ast":null,"code":"'use strict';\n\nvar moduleConfig = require('../utils/module-config');\n\nvar Stream = require('readable-stream');\n\nvar IsIpfs = require('is-ipfs');\n\nvar cleanCID = require('../utils/clean-cid');\n\nmodule.exports = function (arg) {\n  var send = moduleConfig(arg);\n  return function (args, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    try {\n      args = cleanCID(args);\n    } catch (err) {\n      if (!IsIpfs.ipfsPath(args)) {\n        return callback(err);\n      }\n    }\n\n    var pt = new Stream.PassThrough({\n      objectMode: true\n    });\n    send({\n      path: 'ls',\n      args: args,\n      qs: opts\n    }, function (err, results) {\n      if (err) {\n        return callback(err);\n      }\n\n      var result = results.Objects;\n\n      if (!result) {\n        return callback(new Error('expected .Objects in results'));\n      }\n\n      result = result[0];\n\n      if (!result) {\n        return callback(new Error('expected one array in results.Objects'));\n      }\n\n      result = result.Links;\n\n      if (!Array.isArray(result)) {\n        return callback(new Error('expected one array in results.Objects[0].Links'));\n      }\n\n      result = result.map(function (link) {\n        return {\n          depth: 1,\n          name: link.Name,\n          path: args + '/' + link.Name,\n          size: link.Size,\n          hash: link.Hash,\n          type: typeOf(link)\n        };\n      });\n      result.forEach(function (item) {\n        return pt.write(item);\n      });\n      pt.end();\n    });\n    return pt;\n  };\n};\n\nfunction typeOf(link) {\n  switch (link.Type) {\n    case 1:\n    case 5:\n      return 'dir';\n\n    case 2:\n      return 'file';\n\n    default:\n      return 'unknown';\n  }\n}","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/ipfs-http-client/src/files-regular/ls-readable-stream.js"],"names":["moduleConfig","require","Stream","IsIpfs","cleanCID","module","exports","arg","send","args","opts","callback","err","ipfsPath","pt","PassThrough","objectMode","path","qs","results","result","Objects","Error","Links","Array","isArray","map","link","depth","name","Name","size","Size","hash","Hash","type","typeOf","forEach","item","write","end","Type"],"mappings":"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","sourcesContent":["'use strict'\n\nconst moduleConfig = require('../utils/module-config')\nconst Stream = require('readable-stream')\nconst IsIpfs = require('is-ipfs')\nconst cleanCID = require('../utils/clean-cid')\n\nmodule.exports = (arg) => {\n  const send = moduleConfig(arg)\n\n  return (args, opts, callback) => {\n    if (typeof (opts) === 'function') {\n      callback = opts\n      opts = {}\n    }\n\n    try {\n      args = cleanCID(args)\n    } catch (err) {\n      if (!IsIpfs.ipfsPath(args)) {\n        return callback(err)\n      }\n    }\n\n    const pt = new Stream.PassThrough({ objectMode: true })\n\n    send({ path: 'ls', args: args, qs: opts }, (err, results) => {\n      if (err) { return callback(err) }\n\n      let result = results.Objects\n      if (!result) {\n        return callback(new Error('expected .Objects in results'))\n      }\n\n      result = result[0]\n      if (!result) {\n        return callback(new Error('expected one array in results.Objects'))\n      }\n\n      result = result.Links\n      if (!Array.isArray(result)) {\n        return callback(new Error('expected one array in results.Objects[0].Links'))\n      }\n\n      result = result.map((link) => ({\n        depth: 1,\n        name: link.Name,\n        path: args + '/' + link.Name,\n        size: link.Size,\n        hash: link.Hash,\n        type: typeOf(link)\n      }))\n\n      result.forEach((item) => pt.write(item))\n      pt.end()\n    })\n\n    return pt\n  }\n}\n\nfunction typeOf (link) {\n  switch (link.Type) {\n    case 1:\n    case 5:\n      return 'dir'\n    case 2:\n      return 'file'\n    default:\n      return 'unknown'\n  }\n}\n"]},"metadata":{},"sourceType":"script"}