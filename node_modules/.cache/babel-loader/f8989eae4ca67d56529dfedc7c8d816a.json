{"ast":null,"code":"'use strict';\n\nvar webcrypto = require('../webcrypto');\n\nvar nodeify = require('../nodeify');\n\nvar BN = require('asn1.js').bignum;\n\nvar util = require('../util');\n\nvar toBase64 = util.toBase64;\nvar toBn = util.toBn;\nvar bits = {\n  'P-256': 256,\n  'P-384': 384,\n  'P-521': 521\n};\n\nexports.generateEphmeralKeyPair = function (curve, callback) {\n  nodeify(webcrypto.subtle.generateKey({\n    name: 'ECDH',\n    namedCurve: curve\n  }, true, ['deriveBits']).then(function (pair) {\n    // forcePrivate is used for testing only\n    var genSharedKey = function genSharedKey(theirPub, forcePrivate, cb) {\n      if (typeof forcePrivate === 'function') {\n        cb = forcePrivate;\n        forcePrivate = undefined;\n      }\n\n      var privateKey;\n\n      if (forcePrivate) {\n        privateKey = webcrypto.subtle.importKey('jwk', unmarshalPrivateKey(curve, forcePrivate), {\n          name: 'ECDH',\n          namedCurve: curve\n        }, false, ['deriveBits']);\n      } else {\n        privateKey = Promise.resolve(pair.privateKey);\n      }\n\n      var keys = Promise.all([webcrypto.subtle.importKey('jwk', unmarshalPublicKey(curve, theirPub), {\n        name: 'ECDH',\n        namedCurve: curve\n      }, false, []), privateKey]);\n      nodeify(keys.then(function (keys) {\n        return webcrypto.subtle.deriveBits({\n          name: 'ECDH',\n          namedCurve: curve,\n          public: keys[0]\n        }, keys[1], bits[curve]);\n      }).then(function (bits) {\n        return Buffer.from(bits);\n      }), cb);\n    };\n\n    return webcrypto.subtle.exportKey('jwk', pair.publicKey).then(function (publicKey) {\n      return {\n        key: marshalPublicKey(publicKey),\n        genSharedKey: genSharedKey\n      };\n    });\n  }), callback);\n};\n\nvar curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n}; // Marshal converts a jwk encodec ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\n\nfunction marshalPublicKey(jwk) {\n  var byteLen = curveLengths[jwk.crv];\n  return Buffer.concat([Buffer.from([4]), // uncompressed point\n  toBn(jwk.x).toArrayLike(Buffer, 'be', byteLen), toBn(jwk.y).toArrayLike(Buffer, 'be', byteLen)], 1 + byteLen * 2);\n} // Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\n\n\nfunction unmarshalPublicKey(curve, key) {\n  var byteLen = curveLengths[curve];\n\n  if (!key.slice(0, 1).equals(Buffer.from([4]))) {\n    throw new Error('Invalid key format');\n  }\n\n  var x = new BN(key.slice(1, byteLen + 1));\n  var y = new BN(key.slice(1 + byteLen));\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: toBase64(x, byteLen),\n    y: toBase64(y, byteLen),\n    ext: true\n  };\n}\n\nfunction unmarshalPrivateKey(curve, key) {\n  var result = unmarshalPublicKey(curve, key.public);\n  result.d = toBase64(new BN(key.private));\n  return result;\n}","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/libp2p-crypto/src/keys/ecdh-browser.js"],"names":["webcrypto","require","nodeify","BN","bignum","util","toBase64","toBn","bits","exports","generateEphmeralKeyPair","curve","callback","subtle","generateKey","name","namedCurve","then","pair","genSharedKey","theirPub","forcePrivate","cb","undefined","privateKey","importKey","unmarshalPrivateKey","Promise","resolve","keys","all","unmarshalPublicKey","deriveBits","public","Buffer","from","exportKey","publicKey","key","marshalPublicKey","curveLengths","jwk","byteLen","crv","concat","x","toArrayLike","y","slice","equals","Error","kty","ext","result","d","private"],"mappings":"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","sourcesContent":["'use strict'\n\nconst webcrypto = require('../webcrypto')\nconst nodeify = require('../nodeify')\nconst BN = require('asn1.js').bignum\n\nconst util = require('../util')\nconst toBase64 = util.toBase64\nconst toBn = util.toBn\n\nconst bits = {\n  'P-256': 256,\n  'P-384': 384,\n  'P-521': 521\n}\n\nexports.generateEphmeralKeyPair = function (curve, callback) {\n  nodeify(webcrypto.subtle.generateKey(\n    {\n      name: 'ECDH',\n      namedCurve: curve\n    },\n    true,\n    ['deriveBits']\n  ).then((pair) => {\n    // forcePrivate is used for testing only\n    const genSharedKey = (theirPub, forcePrivate, cb) => {\n      if (typeof forcePrivate === 'function') {\n        cb = forcePrivate\n        forcePrivate = undefined\n      }\n\n      let privateKey\n\n      if (forcePrivate) {\n        privateKey = webcrypto.subtle.importKey(\n          'jwk',\n          unmarshalPrivateKey(curve, forcePrivate),\n          {\n            name: 'ECDH',\n            namedCurve: curve\n          },\n          false,\n          ['deriveBits']\n        )\n      } else {\n        privateKey = Promise.resolve(pair.privateKey)\n      }\n\n      const keys = Promise.all([\n        webcrypto.subtle.importKey(\n          'jwk',\n          unmarshalPublicKey(curve, theirPub),\n          {\n            name: 'ECDH',\n            namedCurve: curve\n          },\n          false,\n          []\n        ),\n        privateKey\n      ])\n\n      nodeify(keys.then((keys) => webcrypto.subtle.deriveBits(\n        {\n          name: 'ECDH',\n          namedCurve: curve,\n          public: keys[0]\n        },\n        keys[1],\n        bits[curve]\n      )).then((bits) => Buffer.from(bits)), cb)\n    }\n\n    return webcrypto.subtle.exportKey('jwk', pair.publicKey)\n      .then((publicKey) => {\n        return {\n          key: marshalPublicKey(publicKey),\n          genSharedKey\n        }\n      })\n  }), callback)\n}\n\nconst curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n}\n\n// Marshal converts a jwk encodec ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\nfunction marshalPublicKey (jwk) {\n  const byteLen = curveLengths[jwk.crv]\n\n  return Buffer.concat([\n    Buffer.from([4]), // uncompressed point\n    toBn(jwk.x).toArrayLike(Buffer, 'be', byteLen),\n    toBn(jwk.y).toArrayLike(Buffer, 'be', byteLen)\n  ], 1 + byteLen * 2)\n}\n\n// Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\nfunction unmarshalPublicKey (curve, key) {\n  const byteLen = curveLengths[curve]\n\n  if (!key.slice(0, 1).equals(Buffer.from([4]))) {\n    throw new Error('Invalid key format')\n  }\n  const x = new BN(key.slice(1, byteLen + 1))\n  const y = new BN(key.slice(1 + byteLen))\n\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: toBase64(x, byteLen),\n    y: toBase64(y, byteLen),\n    ext: true\n  }\n}\n\nfunction unmarshalPrivateKey (curve, key) {\n  const result = unmarshalPublicKey(curve, key.public)\n  result.d = toBase64(new BN(key.private))\n  return result\n}\n"]},"metadata":{},"sourceType":"script"}