{"ast":null,"code":"/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar mh = require('multihashes');\n\nvar cryptoKeys = require('libp2p-crypto/src/keys');\n\nvar assert = require('assert');\n\nvar waterfall = require('async/waterfall');\n\nvar withIs = require('class-is');\n\nvar PeerId = /*#__PURE__*/function () {\n  function PeerId(id, privKey, pubKey) {\n    _classCallCheck(this, PeerId);\n\n    assert(Buffer.isBuffer(id), 'invalid id provided');\n\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments');\n    }\n\n    this._id = id;\n    this._idB58String = mh.toB58String(this.id);\n    this._privKey = privKey;\n    this._pubKey = pubKey;\n  }\n\n  _createClass(PeerId, [{\n    key: \"marshalPubKey\",\n    // Return the protobuf version of the public key, matching go ipfs formatting\n    value: function marshalPubKey() {\n      if (this.pubKey) {\n        return cryptoKeys.marshalPublicKey(this.pubKey);\n      }\n    } // Return the protobuf version of the private key, matching go ipfs formatting\n\n  }, {\n    key: \"marshalPrivKey\",\n    value: function marshalPrivKey() {\n      if (this.privKey) {\n        return cryptoKeys.marshalPrivateKey(this.privKey);\n      }\n    }\n  }, {\n    key: \"toPrint\",\n    value: function toPrint() {\n      var pid = this.toB58String(); // All sha256 nodes start with Qm\n      // We can skip the Qm to make the peer.ID more useful\n\n      if (pid.startsWith('Qm')) {\n        pid = pid.slice(2);\n      }\n\n      var maxRunes = 6;\n\n      if (pid.length < maxRunes) {\n        maxRunes = pid.length;\n      }\n\n      return '<peer.ID ' + pid.substr(0, maxRunes) + '>';\n    } // return the jsonified version of the key, matching the formatting\n    // of go-ipfs for its config file\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        id: this.toB58String(),\n        privKey: toB64Opt(this.marshalPrivKey()),\n        pubKey: toB64Opt(this.marshalPubKey())\n      };\n    } // encode/decode functions\n\n  }, {\n    key: \"toHexString\",\n    value: function toHexString() {\n      return mh.toHexString(this.id);\n    }\n  }, {\n    key: \"toBytes\",\n    value: function toBytes() {\n      return this.id;\n    }\n  }, {\n    key: \"toB58String\",\n    value: function toB58String() {\n      return this._idB58String;\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(id) {\n      if (Buffer.isBuffer(id)) {\n        return this.id.equals(id);\n      } else if (id.id) {\n        return this.id.equals(id.id);\n      } else {\n        throw new Error('not valid Id');\n      }\n    }\n    /*\n     * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid(callback) {\n      // TODO Needs better checking\n      if (this.privKey && this.privKey.public && this.privKey.public.bytes && Buffer.isBuffer(this.pubKey.bytes) && this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n        callback();\n      } else {\n        callback(new Error('Keys not match'));\n      }\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    },\n    set: function set(val) {\n      throw new Error('Id is immutable');\n    }\n  }, {\n    key: \"privKey\",\n    get: function get() {\n      return this._privKey;\n    },\n    set: function set(privKey) {\n      this._privKey = privKey;\n    }\n  }, {\n    key: \"pubKey\",\n    get: function get() {\n      if (this._pubKey) {\n        return this._pubKey;\n      }\n\n      if (this._privKey) {\n        return this._privKey.public;\n      }\n\n      var decoded = mh.decode(this.id);\n\n      if (decoded.name === 'identity') {\n        this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest);\n        return this._pubKey;\n      }\n    },\n    set: function set(pubKey) {\n      this._pubKey = pubKey;\n    }\n  }]);\n\n  return PeerId;\n}();\n\nvar PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n});\nexports = module.exports = PeerIdWithIs;\n\nvar computeDigest = function computeDigest(pubKey, cb) {\n  if (pubKey.bytes.length <= 42) {\n    var digest = mh.encode(pubKey.bytes, 'identity');\n    cb(null, digest);\n  } else {\n    pubKey.hash(function (err, digest) {\n      cb(err, digest);\n    });\n  }\n};\n\nvar computePeerId = function computePeerId(privKey, pubKey, cb) {\n  computeDigest(pubKey, function (err, digest) {\n    if (err != null) {\n      cb(err);\n    } else {\n      cb(null, new PeerIdWithIs(digest, privKey, pubKey));\n    }\n  });\n}; // generation\n\n\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n  opts.bits = opts.bits || 2048;\n  opts.keyType = opts.keyType || 'RSA';\n  cryptoKeys.generateKeyPair(opts.keyType, opts.bits, function (err, privKey) {\n    if (err != null) {\n      callback(err);\n    } else {\n      computePeerId(privKey, privKey.public, callback);\n    }\n  });\n};\n\nexports.createFromHexString = function (str) {\n  return new PeerIdWithIs(mh.fromHexString(str));\n};\n\nexports.createFromBytes = function (buf) {\n  return new PeerIdWithIs(buf);\n};\n\nexports.createFromB58String = function (str) {\n  return new PeerIdWithIs(mh.fromB58String(str));\n}; // Public Key input will be a buffer\n\n\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  var pubKey;\n\n  try {\n    var buf = key;\n\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n    pubKey = cryptoKeys.unmarshalPublicKey(buf);\n  } catch (err) {\n    return callback(err);\n  }\n\n  computePeerId(null, pubKey, callback);\n}; // Private key input will be a string\n\n\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  var buf = key;\n\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n  } catch (err) {\n    return callback(err);\n  }\n\n  cryptoKeys.unmarshalPrivateKey(buf, function (err, privKey) {\n    if (err != null) {\n      callback(err);\n    } else {\n      computePeerId(privKey, privKey.public, callback);\n    }\n  });\n};\n\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  var id;\n  var rawPrivKey;\n  var rawPubKey;\n  var pub;\n\n  try {\n    id = mh.fromB58String(obj.id);\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64');\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64');\n    pub = rawPubKey && cryptoKeys.unmarshalPublicKey(rawPubKey);\n  } catch (err) {\n    return callback(err);\n  }\n\n  if (!rawPrivKey) {\n    callback(null, new PeerIdWithIs(id, null, pub));\n    return;\n  }\n\n  waterfall([function (cb) {\n    return cryptoKeys.unmarshalPrivateKey(rawPrivKey, cb);\n  }, function (priv, cb) {\n    computeDigest(priv.public, function (err, digest) {\n      cb(err, digest, priv);\n    });\n  }, function (privDigest, priv, cb) {\n    if (pub) {\n      computeDigest(pub, function (err, pubDigest) {\n        cb(err, privDigest, priv, pubDigest);\n      });\n    } else {\n      cb(null, privDigest, priv);\n    }\n  }], function (err, privDigest, priv, pubDigest) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (pub && !privDigest.equals(pubDigest)) {\n      return callback(new Error('Public and private key do not match'));\n    }\n\n    if (id && !privDigest.equals(id)) {\n      return callback(new Error('Id and private key do not match'));\n    }\n\n    callback(null, new PeerIdWithIs(id, priv, pub));\n  });\n};\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' && peerId._id && peerId._idB58String);\n};\n\nfunction toB64Opt(val) {\n  if (val) {\n    return val.toString('base64');\n  }\n}","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/peer-id/src/index.js"],"names":["mh","require","cryptoKeys","assert","waterfall","withIs","PeerId","id","privKey","pubKey","Buffer","isBuffer","public","bytes","equals","_id","_idB58String","toB58String","_privKey","_pubKey","marshalPublicKey","marshalPrivateKey","pid","startsWith","slice","maxRunes","length","substr","toB64Opt","marshalPrivKey","marshalPubKey","toHexString","Error","callback","val","decoded","decode","name","unmarshalPublicKey","digest","PeerIdWithIs","className","symbolName","exports","module","computeDigest","cb","encode","hash","err","computePeerId","create","opts","bits","keyType","generateKeyPair","createFromHexString","str","fromHexString","createFromBytes","buf","createFromB58String","fromB58String","createFromPubKey","key","from","createFromPrivKey","unmarshalPrivateKey","createFromJSON","obj","rawPrivKey","rawPubKey","pub","priv","privDigest","pubDigest","isPeerId","peerId","Boolean","toString"],"mappings":"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","sourcesContent":["/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n\n'use strict'\n\nconst mh = require('multihashes')\nconst cryptoKeys = require('libp2p-crypto/src/keys')\nconst assert = require('assert')\nconst waterfall = require('async/waterfall')\nconst withIs = require('class-is')\n\nclass PeerId {\n  constructor (id, privKey, pubKey) {\n    assert(Buffer.isBuffer(id), 'invalid id provided')\n\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments')\n    }\n\n    this._id = id\n    this._idB58String = mh.toB58String(this.id)\n    this._privKey = privKey\n    this._pubKey = pubKey\n  }\n\n  get id () {\n    return this._id\n  }\n\n  set id (val) {\n    throw new Error('Id is immutable')\n  }\n\n  get privKey () {\n    return this._privKey\n  }\n\n  set privKey (privKey) {\n    this._privKey = privKey\n  }\n\n  get pubKey () {\n    if (this._pubKey) {\n      return this._pubKey\n    }\n\n    if (this._privKey) {\n      return this._privKey.public\n    }\n\n    const decoded = mh.decode(this.id)\n\n    if (decoded.name === 'identity') {\n      this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest)\n      return this._pubKey\n    }\n  }\n\n  set pubKey (pubKey) {\n    this._pubKey = pubKey\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey () {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey)\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey () {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey)\n    }\n  }\n\n  toPrint () {\n    let pid = this.toB58String()\n    // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2)\n    }\n    let maxRunes = 6\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>'\n  }\n\n  // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n  toJSON () {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    }\n  }\n\n  // encode/decode functions\n  toHexString () {\n    return mh.toHexString(this.id)\n  }\n\n  toBytes () {\n    return this.id\n  }\n\n  toB58String () {\n    return this._idB58String\n  }\n\n  isEqual (id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id)\n    } else if (id.id) {\n      return this.id.equals(id.id)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid (callback) {\n    // TODO Needs better checking\n    if (this.privKey &&\n      this.privKey.public &&\n      this.privKey.public.bytes &&\n      Buffer.isBuffer(this.pubKey.bytes) &&\n      this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n      callback()\n    } else {\n      callback(new Error('Keys not match'))\n    }\n  }\n}\n\nconst PeerIdWithIs = withIs(PeerId, { className: 'PeerId', symbolName: '@libp2p/js-peer-id/PeerId' })\n\nexports = module.exports = PeerIdWithIs\n\nconst computeDigest = (pubKey, cb) => {\n  if (pubKey.bytes.length <= 42) {\n    const digest = mh.encode(pubKey.bytes, 'identity')\n    cb(null, digest)\n  } else {\n    pubKey.hash((err, digest) => {\n      cb(err, digest)\n    })\n  }\n}\n\nconst computePeerId = (privKey, pubKey, cb) => {\n  computeDigest(pubKey, (err, digest) => {\n    if (err != null) {\n      cb(err)\n    } else {\n      cb(null, new PeerIdWithIs(digest, privKey, pubKey))\n    }\n  })\n}\n\n// generation\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  }\n  opts = opts || {}\n  opts.bits = opts.bits || 2048\n  opts.keyType = opts.keyType || 'RSA'\n\n  cryptoKeys.generateKeyPair(opts.keyType, opts.bits, (err, privKey) => {\n    if (err != null) {\n      callback(err)\n    } else {\n      computePeerId(privKey, privKey.public, callback)\n    }\n  })\n}\n\nexports.createFromHexString = function (str) {\n  return new PeerIdWithIs(mh.fromHexString(str))\n}\n\nexports.createFromBytes = function (buf) {\n  return new PeerIdWithIs(buf)\n}\n\nexports.createFromB58String = function (str) {\n  return new PeerIdWithIs(mh.fromB58String(str))\n}\n\n// Public Key input will be a buffer\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let pubKey\n\n  try {\n    let buf = key\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64')\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')\n\n    pubKey = cryptoKeys.unmarshalPublicKey(buf)\n  } catch (err) {\n    return callback(err)\n  }\n\n  computePeerId(null, pubKey, callback)\n}\n\n// Private key input will be a string\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let buf = key\n\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64')\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')\n  } catch (err) {\n    return callback(err)\n  }\n\n  cryptoKeys.unmarshalPrivateKey(buf, (err, privKey) => {\n    if (err != null) {\n      callback(err)\n    } else {\n      computePeerId(privKey, privKey.public, callback)\n    }\n  })\n}\n\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let id\n  let rawPrivKey\n  let rawPubKey\n  let pub\n\n  try {\n    id = mh.fromB58String(obj.id)\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64')\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64')\n    pub = rawPubKey && cryptoKeys.unmarshalPublicKey(rawPubKey)\n  } catch (err) {\n    return callback(err)\n  }\n\n  if (!rawPrivKey) {\n    callback(null, new PeerIdWithIs(id, null, pub))\n    return\n  }\n\n  waterfall([\n    (cb) => cryptoKeys.unmarshalPrivateKey(rawPrivKey, cb),\n    (priv, cb) => {\n      computeDigest(priv.public, (err, digest) => {\n        cb(err, digest, priv)\n      })\n    },\n    (privDigest, priv, cb) => {\n      if (pub) {\n        computeDigest(pub, (err, pubDigest) => {\n          cb(err, privDigest, priv, pubDigest)\n        })\n      } else {\n        cb(null, privDigest, priv)\n      }\n    }\n  ], (err, privDigest, priv, pubDigest) => {\n    if (err) {\n      return callback(err)\n    }\n\n    if (pub && !privDigest.equals(pubDigest)) {\n      return callback(new Error('Public and private key do not match'))\n    }\n\n    if (id && !privDigest.equals(id)) {\n      return callback(new Error('Id and private key do not match'))\n    }\n\n    callback(null, new PeerIdWithIs(id, priv, pub))\n  })\n}\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' &&\n    peerId._id &&\n    peerId._idB58String)\n}\n\nfunction toB64Opt (val) {\n  if (val) {\n    return val.toString('base64')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}