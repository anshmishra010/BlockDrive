{"ast":null,"code":"'use strict';\n\nvar whilst = require('async/whilst');\n\nvar hmac = require('../hmac');\n\nvar cipherMap = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    cipherKeySize: 32\n  }\n}; // Generates a set of keys for each party by stretching the shared key.\n// (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\n\nmodule.exports = function (cipherType, hash, secret, callback) {\n  var cipher = cipherMap[cipherType];\n\n  if (!cipher) {\n    return callback(new Error('unkown cipherType passed'));\n  }\n\n  if (!hash) {\n    return callback(new Error('unkown hashType passed'));\n  }\n\n  var cipherKeySize = cipher.keySize;\n  var ivSize = cipher.ivSize;\n  var hmacKeySize = 20;\n  var seed = Buffer.from('key expansion');\n  var resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);\n  hmac.create(hash, secret, function (err, m) {\n    if (err) {\n      return callback(err);\n    }\n\n    m.digest(seed, function (err, a) {\n      if (err) {\n        return callback(err);\n      }\n\n      var result = [];\n      var j = 0;\n      whilst(function () {\n        return j < resultLength;\n      }, stretch, finish);\n\n      function stretch(cb) {\n        m.digest(Buffer.concat([a, seed]), function (err, b) {\n          if (err) {\n            return cb(err);\n          }\n\n          var todo = b.length;\n\n          if (j + todo > resultLength) {\n            todo = resultLength - j;\n          }\n\n          result.push(b);\n          j += todo;\n          m.digest(a, function (err, _a) {\n            if (err) {\n              return cb(err);\n            }\n\n            a = _a;\n            cb();\n          });\n        });\n      }\n\n      function finish(err) {\n        if (err) {\n          return callback(err);\n        }\n\n        var half = resultLength / 2;\n        var resultBuffer = Buffer.concat(result);\n        var r1 = resultBuffer.slice(0, half);\n        var r2 = resultBuffer.slice(half, resultLength);\n\n        var createKey = function createKey(res) {\n          return {\n            iv: res.slice(0, ivSize),\n            cipherKey: res.slice(ivSize, ivSize + cipherKeySize),\n            macKey: res.slice(ivSize + cipherKeySize)\n          };\n        };\n\n        callback(null, {\n          k1: createKey(r1),\n          k2: createKey(r2)\n        });\n      }\n    });\n  });\n};","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/libp2p-crypto/src/keys/key-stretcher.js"],"names":["whilst","require","hmac","cipherMap","ivSize","keySize","Blowfish","cipherKeySize","module","exports","cipherType","hash","secret","callback","cipher","Error","hmacKeySize","seed","Buffer","from","resultLength","create","err","m","digest","a","result","j","stretch","finish","cb","concat","b","todo","length","push","_a","half","resultBuffer","r1","slice","r2","createKey","res","iv","cipherKey","macKey","k1","k2"],"mappings":"AAAA;;AAEA,IAAMA,MAAM,GAAGC,OAAO,CAAC,cAAD,CAAtB;;AACA,IAAMC,IAAI,GAAGD,OAAO,CAAC,SAAD,CAApB;;AAEA,IAAME,SAAS,GAAG;AAChB,aAAW;AACTC,IAAAA,MAAM,EAAE,EADC;AAETC,IAAAA,OAAO,EAAE;AAFA,GADK;AAKhB,aAAW;AACTD,IAAAA,MAAM,EAAE,EADC;AAETC,IAAAA,OAAO,EAAE;AAFA,GALK;AAShBC,EAAAA,QAAQ,EAAE;AACRF,IAAAA,MAAM,EAAE,CADA;AAERG,IAAAA,aAAa,EAAE;AAFP;AATM,CAAlB,C,CAeA;AACA;;AACAC,MAAM,CAACC,OAAP,GAAiB,UAACC,UAAD,EAAaC,IAAb,EAAmBC,MAAnB,EAA2BC,QAA3B,EAAwC;AACvD,MAAMC,MAAM,GAAGX,SAAS,CAACO,UAAD,CAAxB;;AAEA,MAAI,CAACI,MAAL,EAAa;AACX,WAAOD,QAAQ,CAAC,IAAIE,KAAJ,CAAU,0BAAV,CAAD,CAAf;AACD;;AAED,MAAI,CAACJ,IAAL,EAAW;AACT,WAAOE,QAAQ,CAAC,IAAIE,KAAJ,CAAU,wBAAV,CAAD,CAAf;AACD;;AAED,MAAMR,aAAa,GAAGO,MAAM,CAACT,OAA7B;AACA,MAAMD,MAAM,GAAGU,MAAM,CAACV,MAAtB;AACA,MAAMY,WAAW,GAAG,EAApB;AACA,MAAMC,IAAI,GAAGC,MAAM,CAACC,IAAP,CAAY,eAAZ,CAAb;AACA,MAAMC,YAAY,GAAG,KAAKhB,MAAM,GAAGG,aAAT,GAAyBS,WAA9B,CAArB;AAEAd,EAAAA,IAAI,CAACmB,MAAL,CAAYV,IAAZ,EAAkBC,MAAlB,EAA0B,UAACU,GAAD,EAAMC,CAAN,EAAY;AACpC,QAAID,GAAJ,EAAS;AACP,aAAOT,QAAQ,CAACS,GAAD,CAAf;AACD;;AAEDC,IAAAA,CAAC,CAACC,MAAF,CAASP,IAAT,EAAe,UAACK,GAAD,EAAMG,CAAN,EAAY;AACzB,UAAIH,GAAJ,EAAS;AACP,eAAOT,QAAQ,CAACS,GAAD,CAAf;AACD;;AAED,UAAMI,MAAM,GAAG,EAAf;AACA,UAAIC,CAAC,GAAG,CAAR;AAEA3B,MAAAA,MAAM,CACJ;AAAA,eAAM2B,CAAC,GAAGP,YAAV;AAAA,OADI,EAEJQ,OAFI,EAGJC,MAHI,CAAN;;AAMA,eAASD,OAAT,CAAkBE,EAAlB,EAAsB;AACpBP,QAAAA,CAAC,CAACC,MAAF,CAASN,MAAM,CAACa,MAAP,CAAc,CAACN,CAAD,EAAIR,IAAJ,CAAd,CAAT,EAAmC,UAACK,GAAD,EAAMU,CAAN,EAAY;AAC7C,cAAIV,GAAJ,EAAS;AACP,mBAAOQ,EAAE,CAACR,GAAD,CAAT;AACD;;AAED,cAAIW,IAAI,GAAGD,CAAC,CAACE,MAAb;;AAEA,cAAIP,CAAC,GAAGM,IAAJ,GAAWb,YAAf,EAA6B;AAC3Ba,YAAAA,IAAI,GAAGb,YAAY,GAAGO,CAAtB;AACD;;AAEDD,UAAAA,MAAM,CAACS,IAAP,CAAYH,CAAZ;AAEAL,UAAAA,CAAC,IAAIM,IAAL;AAEAV,UAAAA,CAAC,CAACC,MAAF,CAASC,CAAT,EAAY,UAACH,GAAD,EAAMc,EAAN,EAAa;AACvB,gBAAId,GAAJ,EAAS;AACP,qBAAOQ,EAAE,CAACR,GAAD,CAAT;AACD;;AACDG,YAAAA,CAAC,GAAGW,EAAJ;AACAN,YAAAA,EAAE;AACH,WAND;AAOD,SAtBD;AAuBD;;AAED,eAASD,MAAT,CAAiBP,GAAjB,EAAsB;AACpB,YAAIA,GAAJ,EAAS;AACP,iBAAOT,QAAQ,CAACS,GAAD,CAAf;AACD;;AAED,YAAMe,IAAI,GAAGjB,YAAY,GAAG,CAA5B;AACA,YAAMkB,YAAY,GAAGpB,MAAM,CAACa,MAAP,CAAcL,MAAd,CAArB;AACA,YAAMa,EAAE,GAAGD,YAAY,CAACE,KAAb,CAAmB,CAAnB,EAAsBH,IAAtB,CAAX;AACA,YAAMI,EAAE,GAAGH,YAAY,CAACE,KAAb,CAAmBH,IAAnB,EAAyBjB,YAAzB,CAAX;;AAEA,YAAMsB,SAAS,GAAG,SAAZA,SAAY,CAACC,GAAD;AAAA,iBAAU;AAC1BC,YAAAA,EAAE,EAAED,GAAG,CAACH,KAAJ,CAAU,CAAV,EAAapC,MAAb,CADsB;AAE1ByC,YAAAA,SAAS,EAAEF,GAAG,CAACH,KAAJ,CAAUpC,MAAV,EAAkBA,MAAM,GAAGG,aAA3B,CAFe;AAG1BuC,YAAAA,MAAM,EAAEH,GAAG,CAACH,KAAJ,CAAUpC,MAAM,GAAGG,aAAnB;AAHkB,WAAV;AAAA,SAAlB;;AAMAM,QAAAA,QAAQ,CAAC,IAAD,EAAO;AACbkC,UAAAA,EAAE,EAAEL,SAAS,CAACH,EAAD,CADA;AAEbS,UAAAA,EAAE,EAAEN,SAAS,CAACD,EAAD;AAFA,SAAP,CAAR;AAID;AACF,KA7DD;AA8DD,GAnED;AAoED,CArFD","sourcesContent":["'use strict'\n\nconst whilst = require('async/whilst')\nconst hmac = require('../hmac')\n\nconst cipherMap = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    cipherKeySize: 32\n  }\n}\n\n// Generates a set of keys for each party by stretching the shared key.\n// (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\nmodule.exports = (cipherType, hash, secret, callback) => {\n  const cipher = cipherMap[cipherType]\n\n  if (!cipher) {\n    return callback(new Error('unkown cipherType passed'))\n  }\n\n  if (!hash) {\n    return callback(new Error('unkown hashType passed'))\n  }\n\n  const cipherKeySize = cipher.keySize\n  const ivSize = cipher.ivSize\n  const hmacKeySize = 20\n  const seed = Buffer.from('key expansion')\n  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize)\n\n  hmac.create(hash, secret, (err, m) => {\n    if (err) {\n      return callback(err)\n    }\n\n    m.digest(seed, (err, a) => {\n      if (err) {\n        return callback(err)\n      }\n\n      const result = []\n      let j = 0\n\n      whilst(\n        () => j < resultLength,\n        stretch,\n        finish\n      )\n\n      function stretch (cb) {\n        m.digest(Buffer.concat([a, seed]), (err, b) => {\n          if (err) {\n            return cb(err)\n          }\n\n          let todo = b.length\n\n          if (j + todo > resultLength) {\n            todo = resultLength - j\n          }\n\n          result.push(b)\n\n          j += todo\n\n          m.digest(a, (err, _a) => {\n            if (err) {\n              return cb(err)\n            }\n            a = _a\n            cb()\n          })\n        })\n      }\n\n      function finish (err) {\n        if (err) {\n          return callback(err)\n        }\n\n        const half = resultLength / 2\n        const resultBuffer = Buffer.concat(result)\n        const r1 = resultBuffer.slice(0, half)\n        const r2 = resultBuffer.slice(half, resultLength)\n\n        const createKey = (res) => ({\n          iv: res.slice(0, ivSize),\n          cipherKey: res.slice(ivSize, ivSize + cipherKeySize),\n          macKey: res.slice(ivSize + cipherKeySize)\n        })\n\n        callback(null, {\n          k1: createKey(r1),\n          k2: createKey(r2)\n        })\n      }\n    })\n  })\n}\n"]},"metadata":{},"sourceType":"script"}