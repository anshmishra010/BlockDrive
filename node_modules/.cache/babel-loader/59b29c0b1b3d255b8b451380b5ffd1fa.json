{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar multihashing = require('multihashing-async');\n\nvar protobuf = require('protons');\n\nvar bs58 = require('bs58');\n\nvar nextTick = require('async/nextTick');\n\nvar crypto = require('./rsa');\n\nvar pbm = protobuf(require('./keys.proto'));\n\nrequire('node-forge/lib/sha512');\n\nrequire('node-forge/lib/pbe');\n\nvar forge = require('node-forge/lib/forge');\n\nvar RsaPublicKey = /*#__PURE__*/function () {\n  function RsaPublicKey(key) {\n    _classCallCheck(this, RsaPublicKey);\n\n    this._key = key;\n  }\n\n  _createClass(RsaPublicKey, [{\n    key: \"verify\",\n    value: function verify(data, sig, callback) {\n      ensure(callback);\n      crypto.hashAndVerify(this._key, sig, data, callback);\n    }\n  }, {\n    key: \"marshal\",\n    value: function marshal() {\n      return crypto.utils.jwkToPkix(this._key);\n    }\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(bytes, cb) {\n      var _this = this;\n\n      return cbWrap(function () {\n        return crypto.encrypt(_this._key, bytes);\n      }, cb);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(key) {\n      return this.bytes.equals(key.bytes);\n    }\n  }, {\n    key: \"hash\",\n    value: function hash(callback) {\n      ensure(callback);\n      multihashing(this.bytes, 'sha2-256', callback);\n    }\n  }, {\n    key: \"bytes\",\n    get: function get() {\n      return pbm.PublicKey.encode({\n        Type: pbm.KeyType.RSA,\n        Data: this.marshal()\n      });\n    }\n  }]);\n\n  return RsaPublicKey;\n}();\n\nfunction cbWrap(f, cb) {\n  var res;\n\n  try {\n    res = f();\n  } catch (err) {\n    cb(err);\n  }\n\n  return cb(null, res);\n}\n\nvar RsaPrivateKey = /*#__PURE__*/function () {\n  // key       - Object of the jwk format\n  // publicKey - Buffer of the spki format\n  function RsaPrivateKey(key, publicKey) {\n    _classCallCheck(this, RsaPrivateKey);\n\n    this._key = key;\n    this._publicKey = publicKey;\n  }\n\n  _createClass(RsaPrivateKey, [{\n    key: \"genSecret\",\n    value: function genSecret() {\n      return crypto.getRandomValues(16);\n    }\n  }, {\n    key: \"sign\",\n    value: function sign(message, callback) {\n      ensure(callback);\n      crypto.hashAndSign(this._key, message, callback);\n    }\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(bytes, cb) {\n      var _this2 = this;\n\n      cbWrap(function () {\n        return crypto.decrypt(_this2._key, bytes);\n      }, cb);\n    }\n  }, {\n    key: \"marshal\",\n    value: function marshal() {\n      return crypto.utils.jwkToPkcs1(this._key);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(key) {\n      return this.bytes.equals(key.bytes);\n    }\n  }, {\n    key: \"hash\",\n    value: function hash(callback) {\n      ensure(callback);\n      multihashing(this.bytes, 'sha2-256', callback);\n    }\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     *\n     * @param {function(Error, id)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"id\",\n    value: function id(callback) {\n      this.public.hash(function (err, hash) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, bs58.encode(hash));\n      });\n    }\n    /**\n     * Exports the key into a password protected PEM format\n     *\n     * @param {string} [format] - Defaults to 'pkcs-8'.\n     * @param {string} password - The password to read the encrypted PEM\n     * @param {function(Error, KeyInfo)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"export\",\n    value: function _export(format, password, callback) {\n      var _this3 = this;\n\n      if (typeof password === 'function') {\n        callback = password;\n        password = format;\n        format = 'pkcs-8';\n      }\n\n      ensure(callback);\n      nextTick(function () {\n        var err = null;\n        var pem = null;\n\n        try {\n          var buffer = new forge.util.ByteBuffer(_this3.marshal());\n          var asn1 = forge.asn1.fromDer(buffer);\n          var privateKey = forge.pki.privateKeyFromAsn1(asn1);\n\n          if (format === 'pkcs-8') {\n            var options = {\n              algorithm: 'aes256',\n              count: 10000,\n              saltSize: 128 / 8,\n              prfAlgorithm: 'sha512'\n            };\n            pem = forge.pki.encryptRsaPrivateKey(privateKey, password, options);\n          } else {\n            err = new Error(\"Unknown export format '\".concat(format, \"'\"));\n          }\n        } catch (_err) {\n          err = _err;\n        }\n\n        callback(err, pem);\n      });\n    }\n  }, {\n    key: \"public\",\n    get: function get() {\n      if (!this._publicKey) {\n        throw new Error('public key not provided');\n      }\n\n      return new RsaPublicKey(this._publicKey);\n    }\n  }, {\n    key: \"bytes\",\n    get: function get() {\n      return pbm.PrivateKey.encode({\n        Type: pbm.KeyType.RSA,\n        Data: this.marshal()\n      });\n    }\n  }]);\n\n  return RsaPrivateKey;\n}();\n\nfunction unmarshalRsaPrivateKey(bytes, callback) {\n  var jwk = crypto.utils.pkcs1ToJwk(bytes);\n  crypto.unmarshalPrivateKey(jwk, function (err, keys) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey));\n  });\n}\n\nfunction unmarshalRsaPublicKey(bytes) {\n  var jwk = crypto.utils.pkixToJwk(bytes);\n  return new RsaPublicKey(jwk);\n}\n\nfunction fromJwk(jwk, callback) {\n  crypto.unmarshalPrivateKey(jwk, function (err, keys) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey));\n  });\n}\n\nfunction generateKeyPair(bits, callback) {\n  crypto.generateKey(bits, function (err, keys) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey));\n  });\n}\n\nfunction ensure(callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n}\n\nmodule.exports = {\n  RsaPublicKey: RsaPublicKey,\n  RsaPrivateKey: RsaPrivateKey,\n  unmarshalRsaPublicKey: unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey: unmarshalRsaPrivateKey,\n  generateKeyPair: generateKeyPair,\n  fromJwk: fromJwk\n};","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/libp2p-crypto/src/keys/rsa-class.js"],"names":["multihashing","require","protobuf","bs58","nextTick","crypto","pbm","forge","RsaPublicKey","key","_key","data","sig","callback","ensure","hashAndVerify","utils","jwkToPkix","bytes","cb","cbWrap","encrypt","equals","PublicKey","encode","Type","KeyType","RSA","Data","marshal","f","res","err","RsaPrivateKey","publicKey","_publicKey","getRandomValues","message","hashAndSign","decrypt","jwkToPkcs1","public","hash","format","password","pem","buffer","util","ByteBuffer","asn1","fromDer","privateKey","pki","privateKeyFromAsn1","options","algorithm","count","saltSize","prfAlgorithm","encryptRsaPrivateKey","Error","_err","PrivateKey","unmarshalRsaPrivateKey","jwk","pkcs1ToJwk","unmarshalPrivateKey","keys","unmarshalRsaPublicKey","pkixToJwk","fromJwk","generateKeyPair","bits","generateKey","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst multihashing = require('multihashing-async')\nconst protobuf = require('protons')\nconst bs58 = require('bs58')\nconst nextTick = require('async/nextTick')\n\nconst crypto = require('./rsa')\nconst pbm = protobuf(require('./keys.proto'))\nrequire('node-forge/lib/sha512')\nrequire('node-forge/lib/pbe')\nconst forge = require('node-forge/lib/forge')\n\nclass RsaPublicKey {\n  constructor (key) {\n    this._key = key\n  }\n\n  verify (data, sig, callback) {\n    ensure(callback)\n    crypto.hashAndVerify(this._key, sig, data, callback)\n  }\n\n  marshal () {\n    return crypto.utils.jwkToPkix(this._key)\n  }\n\n  get bytes () {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    })\n  }\n\n  encrypt (bytes, cb) {\n    return cbWrap(() => crypto.encrypt(this._key, bytes), cb)\n  }\n\n  equals (key) {\n    return this.bytes.equals(key.bytes)\n  }\n\n  hash (callback) {\n    ensure(callback)\n    multihashing(this.bytes, 'sha2-256', callback)\n  }\n}\n\nfunction cbWrap (f, cb) {\n  let res\n  try {\n    res = f()\n  } catch (err) {\n    cb(err)\n  }\n\n  return cb(null, res)\n}\n\nclass RsaPrivateKey {\n  // key       - Object of the jwk format\n  // publicKey - Buffer of the spki format\n  constructor (key, publicKey) {\n    this._key = key\n    this._publicKey = publicKey\n  }\n\n  genSecret () {\n    return crypto.getRandomValues(16)\n  }\n\n  sign (message, callback) {\n    ensure(callback)\n    crypto.hashAndSign(this._key, message, callback)\n  }\n\n  get public () {\n    if (!this._publicKey) {\n      throw new Error('public key not provided')\n    }\n\n    return new RsaPublicKey(this._publicKey)\n  }\n\n  decrypt (bytes, cb) {\n    cbWrap(() => crypto.decrypt(this._key, bytes), cb)\n  }\n\n  marshal () {\n    return crypto.utils.jwkToPkcs1(this._key)\n  }\n\n  get bytes () {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    })\n  }\n\n  equals (key) {\n    return this.bytes.equals(key.bytes)\n  }\n\n  hash (callback) {\n    ensure(callback)\n    multihashing(this.bytes, 'sha2-256', callback)\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @param {function(Error, id)} callback\n   * @returns {undefined}\n   */\n  id (callback) {\n    this.public.hash((err, hash) => {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, bs58.encode(hash))\n    })\n  }\n\n  /**\n   * Exports the key into a password protected PEM format\n   *\n   * @param {string} [format] - Defaults to 'pkcs-8'.\n   * @param {string} password - The password to read the encrypted PEM\n   * @param {function(Error, KeyInfo)} callback\n   * @returns {undefined}\n   */\n  export (format, password, callback) {\n    if (typeof password === 'function') {\n      callback = password\n      password = format\n      format = 'pkcs-8'\n    }\n\n    ensure(callback)\n\n    nextTick(() => {\n      let err = null\n      let pem = null\n      try {\n        const buffer = new forge.util.ByteBuffer(this.marshal())\n        const asn1 = forge.asn1.fromDer(buffer)\n        const privateKey = forge.pki.privateKeyFromAsn1(asn1)\n        if (format === 'pkcs-8') {\n          const options = {\n            algorithm: 'aes256',\n            count: 10000,\n            saltSize: 128 / 8,\n            prfAlgorithm: 'sha512'\n          }\n          pem = forge.pki.encryptRsaPrivateKey(privateKey, password, options)\n        } else {\n          err = new Error(`Unknown export format '${format}'`)\n        }\n      } catch (_err) {\n        err = _err\n      }\n\n      callback(err, pem)\n    })\n  }\n}\n\nfunction unmarshalRsaPrivateKey (bytes, callback) {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes)\n\n  crypto.unmarshalPrivateKey(jwk, (err, keys) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey))\n  })\n}\n\nfunction unmarshalRsaPublicKey (bytes) {\n  const jwk = crypto.utils.pkixToJwk(bytes)\n\n  return new RsaPublicKey(jwk)\n}\n\nfunction fromJwk (jwk, callback) {\n  crypto.unmarshalPrivateKey(jwk, (err, keys) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey))\n  })\n}\n\nfunction generateKeyPair (bits, callback) {\n  crypto.generateKey(bits, (err, keys) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new RsaPrivateKey(keys.privateKey, keys.publicKey))\n  })\n}\n\nfunction ensure (callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n}\n\nmodule.exports = {\n  RsaPublicKey,\n  RsaPrivateKey,\n  unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey,\n  generateKeyPair,\n  fromJwk\n}\n"]},"metadata":{},"sourceType":"script"}