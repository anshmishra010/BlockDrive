{"ast":null,"code":"'use strict';\n\nvar _require = require('readable-stream'),\n    Duplex = _require.Duplex;\n\nvar eachSeries = require('async/eachSeries');\n\nvar isStream = require('is-stream');\n\nvar once = require('once');\n\nvar prepareFile = require('./prepare-file');\n\nvar Multipart = require('./multipart');\n\nfunction headers(file, i) {\n  var filename = file.path ? encodeURIComponent(file.path) : '';\n  var header = {\n    'Content-Disposition': \"form-data; name=\\\"data\".concat(i, \"\\\"; filename=\\\"\").concat(filename, \"\\\"\")\n  };\n\n  if (!file.content) {\n    header['Content-Type'] = 'application/x-directory';\n  } else if (file.symlink) {\n    header['Content-Type'] = 'application/symlink';\n  } else {\n    header['Content-Type'] = 'application/octet-stream';\n  }\n\n  return header;\n}\n\nmodule.exports = function (send, path) {\n  return function (options) {\n    var request;\n    var ended = false;\n    var writing = false;\n    options = options ? Object.assign({}, options, options.qs) : {};\n    var multipart = new Multipart();\n    var retStream = new Duplex({\n      objectMode: true\n    });\n\n    retStream._read = function (n) {};\n\n    retStream._write = function (file, enc, _next) {\n      var next = once(_next);\n\n      try {\n        var files = prepareFile(file, options).map(function (file, i) {\n          return Object.assign({\n            headers: headers(file, i)\n          }, file);\n        });\n        writing = true;\n        eachSeries(files, function (file, cb) {\n          return multipart.write(file, enc, cb);\n        }, function (err) {\n          writing = false;\n\n          if (err) {\n            return next(err);\n          }\n\n          if (ended) {\n            multipart.end();\n          }\n\n          next();\n        });\n      } catch (err) {\n        next(err);\n      }\n    };\n\n    retStream.once('finish', function () {\n      if (!ended) {\n        ended = true;\n\n        if (!writing) {\n          multipart.end();\n        }\n      }\n    });\n    var qs = options.qs || {};\n    qs['cid-version'] = propOrProp(options, 'cid-version', 'cidVersion');\n    qs['raw-leaves'] = propOrProp(options, 'raw-leaves', 'rawLeaves');\n    qs['only-hash'] = propOrProp(options, 'only-hash', 'onlyHash');\n    qs['wrap-with-directory'] = propOrProp(options, 'wrap-with-directory', 'wrapWithDirectory');\n    qs.hash = propOrProp(options, 'hash', 'hashAlg');\n\n    if (options.strategy === 'trickle' || options.trickle) {\n      qs['trickle'] = 'true';\n    }\n\n    var args = {\n      path: path,\n      qs: qs,\n      args: options.args,\n      multipart: true,\n      multipartBoundary: multipart._boundary,\n      stream: true,\n      recursive: true,\n      progress: options.progress\n    };\n    multipart.on('error', function (err) {\n      retStream.emit('error', err);\n    });\n    request = send(args, function (err, response) {\n      if (err) {\n        return retStream.emit('error', err);\n      }\n\n      if (!response) {\n        // no response, which means everything is ok, so we end the retStream\n        return retStream.push(null); // early\n      }\n\n      if (!isStream(response)) {\n        retStream.push(response);\n        retStream.push(null);\n        return;\n      }\n\n      response.on('error', function (err) {\n        return retStream.emit('error', err);\n      });\n\n      if (options.converter) {\n        response.on('data', function (d) {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes);\n          }\n        });\n        var Converter = options.converter;\n        var convertedResponse = new Converter();\n        convertedResponse.once('end', function () {\n          return retStream.push(null);\n        });\n        convertedResponse.on('data', function (d) {\n          return retStream.push(d);\n        });\n        response.pipe(convertedResponse);\n      } else {\n        response.on('data', function (d) {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes);\n          }\n\n          retStream.push(d);\n        });\n        response.once('end', function () {\n          return retStream.push(null);\n        });\n      }\n    }); // signal the multipart that the underlying stream has drained and that\n    // it can continue producing data..\n\n    request.on('drain', function () {\n      return multipart.emit('drain');\n    });\n    multipart.pipe(request);\n    return retStream;\n  };\n};\n\nfunction propOrProp(source, prop1, prop2) {\n  if (prop1 in source) {\n    return source[prop1];\n  } else if (prop2 in source) {\n    return source[prop2];\n  }\n}","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/ipfs-http-client/src/utils/send-files-stream.js"],"names":["require","Duplex","eachSeries","isStream","once","prepareFile","Multipart","headers","file","i","filename","path","encodeURIComponent","header","content","symlink","module","exports","send","options","request","ended","writing","Object","assign","qs","multipart","retStream","objectMode","_read","n","_write","enc","_next","next","files","map","cb","write","err","end","propOrProp","hash","strategy","trickle","args","multipartBoundary","_boundary","stream","recursive","progress","on","emit","response","push","converter","d","Bytes","Converter","convertedResponse","pipe","source","prop1","prop2"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Duplex } = require('readable-stream')\nconst eachSeries = require('async/eachSeries')\nconst isStream = require('is-stream')\nconst once = require('once')\nconst prepareFile = require('./prepare-file')\nconst Multipart = require('./multipart')\n\nfunction headers (file, i) {\n  const filename = file.path\n    ? encodeURIComponent(file.path)\n    : ''\n\n  const header = { 'Content-Disposition': `form-data; name=\"data${i}\"; filename=\"${filename}\"` }\n\n  if (!file.content) {\n    header['Content-Type'] = 'application/x-directory'\n  } else if (file.symlink) {\n    header['Content-Type'] = 'application/symlink'\n  } else {\n    header['Content-Type'] = 'application/octet-stream'\n  }\n\n  return header\n}\n\nmodule.exports = (send, path) => {\n  return (options) => {\n    let request\n    let ended = false\n    let writing = false\n\n    options = options ? Object.assign({}, options, options.qs) : {}\n\n    const multipart = new Multipart()\n\n    const retStream = new Duplex({ objectMode: true })\n\n    retStream._read = (n) => {}\n\n    retStream._write = (file, enc, _next) => {\n      const next = once(_next)\n      try {\n        const files = prepareFile(file, options)\n          .map((file, i) => Object.assign({ headers: headers(file, i) }, file))\n\n        writing = true\n        eachSeries(\n          files,\n          (file, cb) => multipart.write(file, enc, cb),\n          (err) => {\n            writing = false\n            if (err) {\n              return next(err)\n            }\n            if (ended) {\n              multipart.end()\n            }\n            next()\n          })\n      } catch (err) {\n        next(err)\n      }\n    }\n\n    retStream.once('finish', () => {\n      if (!ended) {\n        ended = true\n        if (!writing) {\n          multipart.end()\n        }\n      }\n    })\n\n    const qs = options.qs || {}\n\n    qs['cid-version'] = propOrProp(options, 'cid-version', 'cidVersion')\n    qs['raw-leaves'] = propOrProp(options, 'raw-leaves', 'rawLeaves')\n    qs['only-hash'] = propOrProp(options, 'only-hash', 'onlyHash')\n    qs['wrap-with-directory'] = propOrProp(options, 'wrap-with-directory', 'wrapWithDirectory')\n    qs.hash = propOrProp(options, 'hash', 'hashAlg')\n\n    if (options.strategy === 'trickle' || options.trickle) {\n      qs['trickle'] = 'true'\n    }\n\n    const args = {\n      path: path,\n      qs: qs,\n      args: options.args,\n      multipart: true,\n      multipartBoundary: multipart._boundary,\n      stream: true,\n      recursive: true,\n      progress: options.progress\n    }\n\n    multipart.on('error', (err) => {\n      retStream.emit('error', err)\n    })\n\n    request = send(args, (err, response) => {\n      if (err) {\n        return retStream.emit('error', err)\n      }\n\n      if (!response) {\n        // no response, which means everything is ok, so we end the retStream\n        return retStream.push(null) // early\n      }\n\n      if (!isStream(response)) {\n        retStream.push(response)\n        retStream.push(null)\n        return\n      }\n\n      response.on('error', (err) => retStream.emit('error', err))\n\n      if (options.converter) {\n        response.on('data', (d) => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes)\n          }\n        })\n\n        const Converter = options.converter\n        const convertedResponse = new Converter()\n        convertedResponse.once('end', () => retStream.push(null))\n        convertedResponse.on('data', (d) => retStream.push(d))\n        response.pipe(convertedResponse)\n      } else {\n        response.on('data', (d) => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes)\n          }\n          retStream.push(d)\n        })\n        response.once('end', () => retStream.push(null))\n      }\n    })\n\n    // signal the multipart that the underlying stream has drained and that\n    // it can continue producing data..\n    request.on('drain', () => multipart.emit('drain'))\n\n    multipart.pipe(request)\n\n    return retStream\n  }\n}\n\nfunction propOrProp (source, prop1, prop2) {\n  if (prop1 in source) {\n    return source[prop1]\n  } else if (prop2 in source) {\n    return source[prop2]\n  }\n}\n"]},"metadata":{},"sourceType":"script"}