{"ast":null,"code":"'use strict';\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar defined = require('./utils').defined;\n\nvar varint = require('varint');\n\nfunction compileEncode(m, resolve, enc, oneofs, encodingLength) {\n  var oneofsKeys = Object.keys(oneofs);\n  var encLength = enc.length;\n  var ints = {};\n\n  for (var i = 0; i < encLength; i++) {\n    ints[i] = {\n      p: varint.encode(m.fields[i].tag << 3 | 2),\n      h: varint.encode(m.fields[i].tag << 3 | enc[i].type)\n    };\n    var field = m.fields[i];\n    m.fields[i].packed = field.repeated && field.options && field.options.packed && field.options.packed !== 'false';\n  }\n\n  function encodeField(buf, offset, h, e, packed, innerVal) {\n    var j = 0;\n\n    if (!packed) {\n      for (j = 0; j < h.length; j++) {\n        buf[offset++] = h[j];\n      }\n    }\n\n    if (e.message) {\n      varint.encode(e.encodingLength(innerVal), buf, offset);\n      offset += varint.encode.bytes;\n    }\n\n    e.encode(innerVal, buf, offset);\n    return offset + e.encode.bytes;\n  }\n\n  return function encode(obj, buf, offset) {\n    if (offset == null) {\n      offset = 0;\n    }\n\n    if (buf == null) {\n      buf = Buffer.allocUnsafe(encodingLength(obj));\n    }\n\n    var oldOffset = offset;\n    var objKeys = Object.keys(obj);\n    var i = 0; // oneof checks\n\n    var match = false;\n\n    for (i = 0; i < oneofsKeys.length; i++) {\n      var name = oneofsKeys[i];\n      var prop = oneofs[i];\n\n      if (objKeys.indexOf(prop) > -1) {\n        if (match) {\n          throw new Error('only one of the properties defined in oneof ' + name + ' can be set');\n        }\n\n        match = true;\n      }\n    }\n\n    for (i = 0; i < encLength; i++) {\n      var e = enc[i];\n      var field = m.fields[i]; // was f\n\n      var val = obj[field.name];\n      var j = 0;\n\n      if (!defined(val)) {\n        if (field.required) {\n          throw new Error(field.name + ' is required');\n        }\n\n        continue;\n      }\n\n      var p = ints[i].p;\n      var h = ints[i].h;\n      var packed = field.packed;\n\n      if (field.map) {\n        var tmp = Object.keys(val);\n\n        for (j = 0; j < tmp.length; j++) {\n          tmp[j] = {\n            key: tmp[j],\n            value: val[tmp[j]]\n          };\n        }\n\n        val = tmp;\n      }\n\n      if (packed) {\n        var packedLen = 0;\n\n        for (j = 0; j < val.length; j++) {\n          if (!Object.prototype.hasOwnProperty.call(val, j)) {\n            continue;\n          }\n\n          packedLen += e.encodingLength(val[j]);\n        }\n\n        if (packedLen) {\n          for (j = 0; j < h.length; j++) {\n            buf[offset++] = p[j];\n          }\n\n          varint.encode(packedLen, buf, offset);\n          offset += varint.encode.bytes;\n        }\n      }\n\n      if (field.repeated) {\n        var innerVal;\n\n        for (j = 0; j < val.length; j++) {\n          innerVal = val[j];\n\n          if (!defined(innerVal)) {\n            continue;\n          }\n\n          offset = encodeField(buf, offset, h, e, packed, innerVal);\n        }\n      } else {\n        offset = encodeField(buf, offset, h, e, packed, val);\n      }\n    }\n\n    encode.bytes = offset - oldOffset;\n    return buf;\n  };\n}\n\nmodule.exports = compileEncode;","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/protons/src/compile/encode.js"],"names":["require","Buffer","defined","varint","compileEncode","m","resolve","enc","oneofs","encodingLength","oneofsKeys","Object","keys","encLength","length","ints","i","p","encode","fields","tag","h","type","field","packed","repeated","options","encodeField","buf","offset","e","innerVal","j","message","bytes","obj","allocUnsafe","oldOffset","objKeys","match","name","prop","indexOf","Error","val","required","map","tmp","key","value","packedLen","prototype","hasOwnProperty","call","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nconst { Buffer } = require('buffer')\nvar defined = require('./utils').defined\nvar varint = require('varint')\n\nfunction compileEncode (m, resolve, enc, oneofs, encodingLength) {\n  var oneofsKeys = Object.keys(oneofs)\n  var encLength = enc.length\n  var ints = {}\n  for (var i = 0; i < encLength; i++) {\n    ints[i] = {\n      p: varint.encode(m.fields[i].tag << 3 | 2),\n      h: varint.encode(m.fields[i].tag << 3 | enc[i].type)\n    }\n\n    var field = m.fields[i]\n    m.fields[i].packed = field.repeated && field.options && field.options.packed && field.options.packed !== 'false'\n  }\n\n  function encodeField (buf, offset, h, e, packed, innerVal) {\n    var j = 0\n    if (!packed) {\n      for (j = 0; j < h.length; j++) {\n        buf[offset++] = h[j]\n      }\n    }\n\n    if (e.message) {\n      varint.encode(e.encodingLength(innerVal), buf, offset)\n      offset += varint.encode.bytes\n    }\n\n    e.encode(innerVal, buf, offset)\n    return offset + e.encode.bytes\n  }\n\n  return function encode (obj, buf, offset) {\n    if (offset == null) {\n      offset = 0\n    }\n    if (buf == null) {\n      buf = Buffer.allocUnsafe(encodingLength(obj))\n    }\n\n    var oldOffset = offset\n    var objKeys = Object.keys(obj)\n    var i = 0\n\n    // oneof checks\n\n    var match = false\n    for (i = 0; i < oneofsKeys.length; i++) {\n      var name = oneofsKeys[i]\n      var prop = oneofs[i]\n      if (objKeys.indexOf(prop) > -1) {\n        if (match) {\n          throw new Error('only one of the properties defined in oneof ' + name + ' can be set')\n        }\n\n        match = true\n      }\n    }\n\n    for (i = 0; i < encLength; i++) {\n      var e = enc[i]\n      var field = m.fields[i] // was f\n      var val = obj[field.name]\n      var j = 0\n\n      if (!defined(val)) {\n        if (field.required) {\n          throw new Error(field.name + ' is required')\n        }\n        continue\n      }\n      var p = ints[i].p\n      var h = ints[i].h\n\n      var packed = field.packed\n\n      if (field.map) {\n        var tmp = Object.keys(val)\n        for (j = 0; j < tmp.length; j++) {\n          tmp[j] = {\n            key: tmp[j],\n            value: val[tmp[j]]\n          }\n        }\n        val = tmp\n      }\n\n      if (packed) {\n        var packedLen = 0\n        for (j = 0; j < val.length; j++) {\n          if (!Object.prototype.hasOwnProperty.call(val, j)) {\n            continue\n          }\n\n          packedLen += e.encodingLength(val[j])\n        }\n\n        if (packedLen) {\n          for (j = 0; j < h.length; j++) {\n            buf[offset++] = p[j]\n          }\n          varint.encode(packedLen, buf, offset)\n          offset += varint.encode.bytes\n        }\n      }\n\n      if (field.repeated) {\n        var innerVal\n        for (j = 0; j < val.length; j++) {\n          innerVal = val[j]\n          if (!defined(innerVal)) {\n            continue\n          }\n          offset = encodeField(buf, offset, h, e, packed, innerVal)\n        }\n      } else {\n        offset = encodeField(buf, offset, h, e, packed, val)\n      }\n    }\n\n    encode.bytes = offset - oldOffset\n    return buf\n  }\n}\n\nmodule.exports = compileEncode\n"]},"metadata":{},"sourceType":"script"}