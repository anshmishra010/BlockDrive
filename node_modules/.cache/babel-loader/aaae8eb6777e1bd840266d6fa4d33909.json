{"ast":null,"code":"'use strict';\n\nvar dagPB = require('ipld-dag-pb');\n\nvar dagCBOR = require('ipld-dag-cbor');\n\nvar raw = require('ipld-raw');\n\nvar promisify = require('promisify-es6');\n\nvar CID = require('cids');\n\nvar waterfall = require('async/waterfall');\n\nvar block = require('../block');\n\nvar resolvers = {\n  'dag-cbor': dagCBOR.resolver,\n  'dag-pb': dagPB.resolver,\n  raw: raw.resolver\n};\n\nmodule.exports = function (send) {\n  return promisify(function (cid, path, options, callback) {\n    if (typeof path === 'function') {\n      callback = path;\n      path = undefined;\n    }\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {};\n    path = path || '';\n\n    if (CID.isCID(cid)) {\n      cid = cid.toBaseEncodedString();\n    }\n\n    waterfall([function (cb) {\n      send({\n        path: 'dag/resolve',\n        args: cid + '/' + path,\n        qs: options\n      }, cb);\n    }, function (resolved, cb) {\n      block(send).get(new CID(resolved['Cid']['/']), function (err, ipfsBlock) {\n        cb(err, ipfsBlock, resolved['RemPath']);\n      });\n    }, function (ipfsBlock, path, cb) {\n      var dagResolver = resolvers[ipfsBlock.cid.codec];\n\n      if (!dagResolver) {\n        var error = new Error(\"Missing IPLD format \\\"\".concat(ipfsBlock.cid.codec, \"\\\"\"));\n        error.missingMulticodec = ipfsBlock.cid.codec;\n        return cb(error);\n      }\n\n      var res;\n\n      try {\n        res = dagResolver.resolve(ipfsBlock.data, path);\n      } catch (err) {\n        return cb(err);\n      }\n\n      cb(null, res);\n    }], callback);\n  });\n};","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/ipfs-http-client/src/dag/get.js"],"names":["dagPB","require","dagCBOR","raw","promisify","CID","waterfall","block","resolvers","resolver","module","exports","send","cid","path","options","callback","undefined","isCID","toBaseEncodedString","cb","args","qs","resolved","get","err","ipfsBlock","dagResolver","codec","error","Error","missingMulticodec","res","resolve","data"],"mappings":"AAAA;;AAEA,IAAMA,KAAK,GAAGC,OAAO,CAAC,aAAD,CAArB;;AACA,IAAMC,OAAO,GAAGD,OAAO,CAAC,eAAD,CAAvB;;AACA,IAAME,GAAG,GAAGF,OAAO,CAAC,UAAD,CAAnB;;AACA,IAAMG,SAAS,GAAGH,OAAO,CAAC,eAAD,CAAzB;;AACA,IAAMI,GAAG,GAAGJ,OAAO,CAAC,MAAD,CAAnB;;AACA,IAAMK,SAAS,GAAGL,OAAO,CAAC,iBAAD,CAAzB;;AACA,IAAMM,KAAK,GAAGN,OAAO,CAAC,UAAD,CAArB;;AAEA,IAAMO,SAAS,GAAG;AAChB,cAAYN,OAAO,CAACO,QADJ;AAEhB,YAAUT,KAAK,CAACS,QAFA;AAGhBN,EAAAA,GAAG,EAAEA,GAAG,CAACM;AAHO,CAAlB;;AAMAC,MAAM,CAACC,OAAP,GAAiB,UAACC,IAAD,EAAU;AACzB,SAAOR,SAAS,CAAC,UAACS,GAAD,EAAMC,IAAN,EAAYC,OAAZ,EAAqBC,QAArB,EAAkC;AACjD,QAAI,OAAOF,IAAP,KAAgB,UAApB,EAAgC;AAC9BE,MAAAA,QAAQ,GAAGF,IAAX;AACAA,MAAAA,IAAI,GAAGG,SAAP;AACD;;AAED,QAAI,OAAOF,OAAP,KAAmB,UAAvB,EAAmC;AACjCC,MAAAA,QAAQ,GAAGD,OAAX;AACAA,MAAAA,OAAO,GAAG,EAAV;AACD;;AAEDA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACAD,IAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;;AAEA,QAAIT,GAAG,CAACa,KAAJ,CAAUL,GAAV,CAAJ,EAAoB;AAClBA,MAAAA,GAAG,GAAGA,GAAG,CAACM,mBAAJ,EAAN;AACD;;AAEDb,IAAAA,SAAS,CAAC,CACR,UAAAc,EAAE,EAAI;AACJR,MAAAA,IAAI,CAAC;AACHE,QAAAA,IAAI,EAAE,aADH;AAEHO,QAAAA,IAAI,EAAER,GAAG,GAAG,GAAN,GAAYC,IAFf;AAGHQ,QAAAA,EAAE,EAAEP;AAHD,OAAD,EAIDK,EAJC,CAAJ;AAKD,KAPO,EAQR,UAACG,QAAD,EAAWH,EAAX,EAAkB;AAChBb,MAAAA,KAAK,CAACK,IAAD,CAAL,CAAYY,GAAZ,CAAgB,IAAInB,GAAJ,CAAQkB,QAAQ,CAAC,KAAD,CAAR,CAAgB,GAAhB,CAAR,CAAhB,EAA+C,UAACE,GAAD,EAAMC,SAAN,EAAoB;AACjEN,QAAAA,EAAE,CAACK,GAAD,EAAMC,SAAN,EAAiBH,QAAQ,CAAC,SAAD,CAAzB,CAAF;AACD,OAFD;AAGD,KAZO,EAaR,UAACG,SAAD,EAAYZ,IAAZ,EAAkBM,EAAlB,EAAyB;AACvB,UAAMO,WAAW,GAAGnB,SAAS,CAACkB,SAAS,CAACb,GAAV,CAAce,KAAf,CAA7B;;AAEA,UAAI,CAACD,WAAL,EAAkB;AAChB,YAAME,KAAK,GAAG,IAAIC,KAAJ,iCAAkCJ,SAAS,CAACb,GAAV,CAAce,KAAhD,QAAd;AACAC,QAAAA,KAAK,CAACE,iBAAN,GAA0BL,SAAS,CAACb,GAAV,CAAce,KAAxC;AACA,eAAOR,EAAE,CAACS,KAAD,CAAT;AACD;;AAED,UAAIG,GAAJ;;AACA,UAAI;AACFA,QAAAA,GAAG,GAAGL,WAAW,CAACM,OAAZ,CAAoBP,SAAS,CAACQ,IAA9B,EAAoCpB,IAApC,CAAN;AACD,OAFD,CAEE,OAAOW,GAAP,EAAY;AACZ,eAAOL,EAAE,CAACK,GAAD,CAAT;AACD;;AAEDL,MAAAA,EAAE,CAAC,IAAD,EAAOY,GAAP,CAAF;AACD,KA9BO,CAAD,EA+BNhB,QA/BM,CAAT;AAgCD,GAlDe,CAAhB;AAmDD,CApDD","sourcesContent":["'use strict'\n\nconst dagPB = require('ipld-dag-pb')\nconst dagCBOR = require('ipld-dag-cbor')\nconst raw = require('ipld-raw')\nconst promisify = require('promisify-es6')\nconst CID = require('cids')\nconst waterfall = require('async/waterfall')\nconst block = require('../block')\n\nconst resolvers = {\n  'dag-cbor': dagCBOR.resolver,\n  'dag-pb': dagPB.resolver,\n  raw: raw.resolver\n}\n\nmodule.exports = (send) => {\n  return promisify((cid, path, options, callback) => {\n    if (typeof path === 'function') {\n      callback = path\n      path = undefined\n    }\n\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    }\n\n    options = options || {}\n    path = path || ''\n\n    if (CID.isCID(cid)) {\n      cid = cid.toBaseEncodedString()\n    }\n\n    waterfall([\n      cb => {\n        send({\n          path: 'dag/resolve',\n          args: cid + '/' + path,\n          qs: options\n        }, cb)\n      },\n      (resolved, cb) => {\n        block(send).get(new CID(resolved['Cid']['/']), (err, ipfsBlock) => {\n          cb(err, ipfsBlock, resolved['RemPath'])\n        })\n      },\n      (ipfsBlock, path, cb) => {\n        const dagResolver = resolvers[ipfsBlock.cid.codec]\n\n        if (!dagResolver) {\n          const error = new Error(`Missing IPLD format \"${ipfsBlock.cid.codec}\"`)\n          error.missingMulticodec = ipfsBlock.cid.codec\n          return cb(error)\n        }\n\n        let res\n        try {\n          res = dagResolver.resolve(ipfsBlock.data, path)\n        } catch (err) {\n          return cb(err)\n        }\n\n        cb(null, res)\n      }\n    ], callback)\n  })\n}\n"]},"metadata":{},"sourceType":"script"}