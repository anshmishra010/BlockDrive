{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar sha3 = require('js-sha3');\n\nvar mur = require('murmurhash3js-revisited');\n\nvar _require2 = require('./sha'),\n    sha = _require2.factory;\n\nvar _require3 = require('./utils'),\n    fromNumberTo32BitBuf = _require3.fromNumberTo32BitBuf; // Note that although this function doesn't do any asynchronous work, we mark\n// the function as async because it must return a Promise to match the API\n// for other functions that do perform asynchronous work (see sha.browser.js)\n// eslint-disable-next-line\n\n\nvar hash = function hash(algorithm) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data) {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.t0 = algorithm;\n              _context.next = _context.t0 === 'sha3-224' ? 3 : _context.t0 === 'sha3-256' ? 4 : _context.t0 === 'sha3-384' ? 5 : _context.t0 === 'sha3-512' ? 6 : _context.t0 === 'shake-128' ? 7 : _context.t0 === 'shake-256' ? 8 : _context.t0 === 'keccak-224' ? 9 : _context.t0 === 'keccak-256' ? 10 : _context.t0 === 'keccak-384' ? 11 : _context.t0 === 'keccak-512' ? 12 : _context.t0 === 'murmur3-128' ? 13 : _context.t0 === 'murmur3-32' ? 14 : 15;\n              break;\n\n            case 3:\n              return _context.abrupt(\"return\", Buffer.from(sha3.sha3_224.arrayBuffer(data)));\n\n            case 4:\n              return _context.abrupt(\"return\", Buffer.from(sha3.sha3_256.arrayBuffer(data)));\n\n            case 5:\n              return _context.abrupt(\"return\", Buffer.from(sha3.sha3_384.arrayBuffer(data)));\n\n            case 6:\n              return _context.abrupt(\"return\", Buffer.from(sha3.sha3_512.arrayBuffer(data)));\n\n            case 7:\n              return _context.abrupt(\"return\", Buffer.from(sha3.shake128.create(128).update(data).arrayBuffer()));\n\n            case 8:\n              return _context.abrupt(\"return\", Buffer.from(sha3.shake256.create(256).update(data).arrayBuffer()));\n\n            case 9:\n              return _context.abrupt(\"return\", Buffer.from(sha3.keccak224.arrayBuffer(data)));\n\n            case 10:\n              return _context.abrupt(\"return\", Buffer.from(sha3.keccak256.arrayBuffer(data)));\n\n            case 11:\n              return _context.abrupt(\"return\", Buffer.from(sha3.keccak384.arrayBuffer(data)));\n\n            case 12:\n              return _context.abrupt(\"return\", Buffer.from(sha3.keccak512.arrayBuffer(data)));\n\n            case 13:\n              return _context.abrupt(\"return\", Buffer.from(mur.x64.hash128(data), 'hex'));\n\n            case 14:\n              return _context.abrupt(\"return\", fromNumberTo32BitBuf(mur.x86.hash32(data)));\n\n            case 15:\n              throw new TypeError(\"\".concat(algorithm, \" is not a supported algorithm\"));\n\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\n\nvar identity = function identity(data) {\n  return Buffer.from(data);\n};\n\nmodule.exports = {\n  identity: identity,\n  sha1: sha('sha1'),\n  sha2256: sha('sha2-256'),\n  sha2512: sha('sha2-512'),\n  dblSha2256: sha('dbl-sha2-256'),\n  sha3224: hash('sha3-224'),\n  sha3256: hash('sha3-256'),\n  sha3384: hash('sha3-384'),\n  sha3512: hash('sha3-512'),\n  shake128: hash('shake-128'),\n  shake256: hash('shake-256'),\n  keccak224: hash('keccak-224'),\n  keccak256: hash('keccak-256'),\n  keccak384: hash('keccak-384'),\n  keccak512: hash('keccak-512'),\n  murmur3128: hash('murmur3-128'),\n  murmur332: hash('murmur3-32'),\n  addBlake: require('./blake')\n};","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/multihashing-async/src/crypto.js"],"names":["require","Buffer","sha3","mur","sha","factory","fromNumberTo32BitBuf","hash","algorithm","data","from","sha3_224","arrayBuffer","sha3_256","sha3_384","sha3_512","shake128","create","update","shake256","keccak224","keccak256","keccak384","keccak512","x64","hash128","x86","hash32","TypeError","identity","module","exports","sha1","sha2256","sha2512","dblSha2256","sha3224","sha3256","sha3384","sha3512","murmur3128","murmur332","addBlake"],"mappings":"AAAA;;;;;;eAEmBA,OAAO,CAAC,QAAD,C;IAAlBC,M,YAAAA,M;;AACR,IAAMC,IAAI,GAAGF,OAAO,CAAC,SAAD,CAApB;;AACA,IAAMG,GAAG,GAAGH,OAAO,CAAC,yBAAD,CAAnB;;gBACyBA,OAAO,CAAC,OAAD,C;IAAfI,G,aAATC,O;;gBACyBL,OAAO,CAAC,SAAD,C;IAAhCM,oB,aAAAA,oB,EAER;AACA;AACA;AACA;;;AACA,IAAMC,IAAI,GAAG,SAAPA,IAAO,CAACC,SAAD;AAAA;AAAA,wEAAe,iBAAOC,IAAP;AAAA;AAAA;AAAA;AAAA;AAAA,4BAClBD,SADkB;AAAA,8CAEnB,UAFmB,uBAInB,UAJmB,uBAMnB,UANmB,uBAQnB,UARmB,uBAUnB,WAVmB,uBAYnB,WAZmB,uBAcnB,YAdmB,uBAgBnB,YAhBmB,wBAkBnB,YAlBmB,wBAoBnB,YApBmB,wBAsBnB,aAtBmB,wBAwBnB,YAxBmB;AAAA;;AAAA;AAAA,+CAGfP,MAAM,CAACS,IAAP,CAAYR,IAAI,CAACS,QAAL,CAAcC,WAAd,CAA0BH,IAA1B,CAAZ,CAHe;;AAAA;AAAA,+CAKfR,MAAM,CAACS,IAAP,CAAYR,IAAI,CAACW,QAAL,CAAcD,WAAd,CAA0BH,IAA1B,CAAZ,CALe;;AAAA;AAAA,+CAOfR,MAAM,CAACS,IAAP,CAAYR,IAAI,CAACY,QAAL,CAAcF,WAAd,CAA0BH,IAA1B,CAAZ,CAPe;;AAAA;AAAA,+CASfR,MAAM,CAACS,IAAP,CAAYR,IAAI,CAACa,QAAL,CAAcH,WAAd,CAA0BH,IAA1B,CAAZ,CATe;;AAAA;AAAA,+CAWfR,MAAM,CAACS,IAAP,CAAYR,IAAI,CAACc,QAAL,CAAcC,MAAd,CAAqB,GAArB,EAA0BC,MAA1B,CAAiCT,IAAjC,EAAuCG,WAAvC,EAAZ,CAXe;;AAAA;AAAA,+CAafX,MAAM,CAACS,IAAP,CAAYR,IAAI,CAACiB,QAAL,CAAcF,MAAd,CAAqB,GAArB,EAA0BC,MAA1B,CAAiCT,IAAjC,EAAuCG,WAAvC,EAAZ,CAbe;;AAAA;AAAA,+CAefX,MAAM,CAACS,IAAP,CAAYR,IAAI,CAACkB,SAAL,CAAeR,WAAf,CAA2BH,IAA3B,CAAZ,CAfe;;AAAA;AAAA,+CAiBfR,MAAM,CAACS,IAAP,CAAYR,IAAI,CAACmB,SAAL,CAAeT,WAAf,CAA2BH,IAA3B,CAAZ,CAjBe;;AAAA;AAAA,+CAmBfR,MAAM,CAACS,IAAP,CAAYR,IAAI,CAACoB,SAAL,CAAeV,WAAf,CAA2BH,IAA3B,CAAZ,CAnBe;;AAAA;AAAA,+CAqBfR,MAAM,CAACS,IAAP,CAAYR,IAAI,CAACqB,SAAL,CAAeX,WAAf,CAA2BH,IAA3B,CAAZ,CArBe;;AAAA;AAAA,+CAuBfR,MAAM,CAACS,IAAP,CAAYP,GAAG,CAACqB,GAAJ,CAAQC,OAAR,CAAgBhB,IAAhB,CAAZ,EAAmC,KAAnC,CAvBe;;AAAA;AAAA,+CAyBfH,oBAAoB,CAACH,GAAG,CAACuB,GAAJ,CAAQC,MAAR,CAAelB,IAAf,CAAD,CAzBL;;AAAA;AAAA,oBA4BhB,IAAImB,SAAJ,WAAiBpB,SAAjB,mCA5BgB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAf;;AAAA;AAAA;AAAA;AAAA;AAAA,CAAb;;AAgCA,IAAMqB,QAAQ,GAAG,SAAXA,QAAW,CAAApB,IAAI;AAAA,SAAIR,MAAM,CAACS,IAAP,CAAYD,IAAZ,CAAJ;AAAA,CAArB;;AAEAqB,MAAM,CAACC,OAAP,GAAiB;AACfF,EAAAA,QAAQ,EAARA,QADe;AAEfG,EAAAA,IAAI,EAAE5B,GAAG,CAAC,MAAD,CAFM;AAGf6B,EAAAA,OAAO,EAAE7B,GAAG,CAAC,UAAD,CAHG;AAIf8B,EAAAA,OAAO,EAAE9B,GAAG,CAAC,UAAD,CAJG;AAKf+B,EAAAA,UAAU,EAAE/B,GAAG,CAAC,cAAD,CALA;AAMfgC,EAAAA,OAAO,EAAE7B,IAAI,CAAC,UAAD,CANE;AAOf8B,EAAAA,OAAO,EAAE9B,IAAI,CAAC,UAAD,CAPE;AAQf+B,EAAAA,OAAO,EAAE/B,IAAI,CAAC,UAAD,CARE;AASfgC,EAAAA,OAAO,EAAEhC,IAAI,CAAC,UAAD,CATE;AAUfS,EAAAA,QAAQ,EAAET,IAAI,CAAC,WAAD,CAVC;AAWfY,EAAAA,QAAQ,EAAEZ,IAAI,CAAC,WAAD,CAXC;AAYfa,EAAAA,SAAS,EAAEb,IAAI,CAAC,YAAD,CAZA;AAafc,EAAAA,SAAS,EAAEd,IAAI,CAAC,YAAD,CAbA;AAcfe,EAAAA,SAAS,EAAEf,IAAI,CAAC,YAAD,CAdA;AAefgB,EAAAA,SAAS,EAAEhB,IAAI,CAAC,YAAD,CAfA;AAgBfiC,EAAAA,UAAU,EAAEjC,IAAI,CAAC,aAAD,CAhBD;AAiBfkC,EAAAA,SAAS,EAAElC,IAAI,CAAC,YAAD,CAjBA;AAkBfmC,EAAAA,QAAQ,EAAE1C,OAAO,CAAC,SAAD;AAlBF,CAAjB","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst sha3 = require('js-sha3')\nconst mur = require('murmurhash3js-revisited')\nconst { factory: sha } = require('./sha')\nconst { fromNumberTo32BitBuf } = require('./utils')\n\n// Note that although this function doesn't do any asynchronous work, we mark\n// the function as async because it must return a Promise to match the API\n// for other functions that do perform asynchronous work (see sha.browser.js)\n// eslint-disable-next-line\nconst hash = (algorithm) => async (data) => {\n  switch (algorithm) {\n    case 'sha3-224':\n      return Buffer.from(sha3.sha3_224.arrayBuffer(data))\n    case 'sha3-256':\n      return Buffer.from(sha3.sha3_256.arrayBuffer(data))\n    case 'sha3-384':\n      return Buffer.from(sha3.sha3_384.arrayBuffer(data))\n    case 'sha3-512':\n      return Buffer.from(sha3.sha3_512.arrayBuffer(data))\n    case 'shake-128':\n      return Buffer.from(sha3.shake128.create(128).update(data).arrayBuffer())\n    case 'shake-256':\n      return Buffer.from(sha3.shake256.create(256).update(data).arrayBuffer())\n    case 'keccak-224':\n      return Buffer.from(sha3.keccak224.arrayBuffer(data))\n    case 'keccak-256':\n      return Buffer.from(sha3.keccak256.arrayBuffer(data))\n    case 'keccak-384':\n      return Buffer.from(sha3.keccak384.arrayBuffer(data))\n    case 'keccak-512':\n      return Buffer.from(sha3.keccak512.arrayBuffer(data))\n    case 'murmur3-128':\n      return Buffer.from(mur.x64.hash128(data), 'hex')\n    case 'murmur3-32':\n      return fromNumberTo32BitBuf(mur.x86.hash32(data))\n\n    default:\n      throw new TypeError(`${algorithm} is not a supported algorithm`)\n  }\n}\n\nconst identity = data => Buffer.from(data)\n\nmodule.exports = {\n  identity,\n  sha1: sha('sha1'),\n  sha2256: sha('sha2-256'),\n  sha2512: sha('sha2-512'),\n  dblSha2256: sha('dbl-sha2-256'),\n  sha3224: hash('sha3-224'),\n  sha3256: hash('sha3-256'),\n  sha3384: hash('sha3-384'),\n  sha3512: hash('sha3-512'),\n  shake128: hash('shake-128'),\n  shake256: hash('shake-256'),\n  keccak224: hash('keccak-224'),\n  keccak256: hash('keccak-256'),\n  keccak384: hash('keccak-384'),\n  keccak512: hash('keccak-512'),\n  murmur3128: hash('murmur3-128'),\n  murmur332: hash('murmur3-32'),\n  addBlake: require('./blake')\n}\n"]},"metadata":{},"sourceType":"script"}