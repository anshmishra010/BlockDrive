{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar CID = require('cids');\n\nvar assert = require('assert');\n\nvar withIs = require('class-is');\n\nvar visibility = require('../visibility'); // Link represents an IPFS Merkle DAG Link between Nodes.\n\n\nvar DAGLink = /*#__PURE__*/function () {\n  function DAGLink(name, size, cid) {\n    _classCallCheck(this, DAGLink);\n\n    assert(cid, 'A link requires a cid to point to'); // assert(size, 'A link requires a size')\n    //  note - links should include size, but this assert is disabled\n    //  for now to maintain consistency with go-ipfs pinset\n\n    this._name = name || '';\n    this._nameBuf = null;\n    this._size = size;\n    this._cid = new CID(cid); // Make sure we have a nice public API that can be used by an IPLD resolver\n\n    visibility.hidePrivateFields(this);\n    visibility.addEnumerableGetters(this, ['Hash', 'Name', 'Tsize']);\n  }\n\n  _createClass(DAGLink, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"DAGLink <\".concat(this._cid.toBaseEncodedString(), \" - name: \\\"\").concat(this.Name, \"\\\", size: \").concat(this.Tsize, \">\");\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      if (!this._json) {\n        this._json = Object.freeze({\n          name: this.Name,\n          size: this.Tsize,\n          cid: this.Hash.toBaseEncodedString()\n        });\n      }\n\n      return Object.assign({}, this._json);\n    }\n  }, {\n    key: \"Name\",\n    get: function get() {\n      return this._name;\n    } // Memoize the Buffer representation of name\n    // We need this to sort the links, otherwise\n    // we will reallocate new buffers every time\n    ,\n    set: function set(name) {\n      throw new Error(\"Can't set property: 'name' is immutable\");\n    }\n  }, {\n    key: \"nameAsBuffer\",\n    get: function get() {\n      if (this._nameBuf !== null) {\n        return this._nameBuf;\n      }\n\n      this._nameBuf = Buffer.from(this._name);\n      return this._nameBuf;\n    }\n  }, {\n    key: \"Tsize\",\n    get: function get() {\n      return this._size;\n    },\n    set: function set(size) {\n      throw new Error(\"Can't set property: 'size' is immutable\");\n    }\n  }, {\n    key: \"Hash\",\n    get: function get() {\n      return this._cid;\n    },\n    set: function set(cid) {\n      throw new Error(\"Can't set property: 'cid' is immutable\");\n    }\n  }]);\n\n  return DAGLink;\n}();\n\nexports = module.exports = withIs(DAGLink, {\n  className: 'DAGLink',\n  symbolName: '@ipld/js-ipld-dag-pb/daglink'\n});\nexports.util = require('./util');","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/ipld-dag-pb/src/dag-link/index.js"],"names":["CID","require","assert","withIs","visibility","DAGLink","name","size","cid","_name","_nameBuf","_size","_cid","hidePrivateFields","addEnumerableGetters","toBaseEncodedString","Name","Tsize","_json","Object","freeze","Hash","assign","Error","Buffer","from","exports","module","className","symbolName","util"],"mappings":"AAAA;;;;;;AAEA,IAAMA,GAAG,GAAGC,OAAO,CAAC,MAAD,CAAnB;;AACA,IAAMC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAME,MAAM,GAAGF,OAAO,CAAC,UAAD,CAAtB;;AACA,IAAMG,UAAU,GAAGH,OAAO,CAAC,eAAD,CAA1B,C,CAEA;;;IACMI,O;AACJ,mBAAaC,IAAb,EAAmBC,IAAnB,EAAyBC,GAAzB,EAA8B;AAAA;;AAC5BN,IAAAA,MAAM,CAACM,GAAD,EAAM,mCAAN,CAAN,CAD4B,CAE5B;AACA;AACA;;AAEA,SAAKC,KAAL,GAAaH,IAAI,IAAI,EAArB;AACA,SAAKI,QAAL,GAAgB,IAAhB;AACA,SAAKC,KAAL,GAAaJ,IAAb;AACA,SAAKK,IAAL,GAAY,IAAIZ,GAAJ,CAAQQ,GAAR,CAAZ,CAT4B,CAW5B;;AACAJ,IAAAA,UAAU,CAACS,iBAAX,CAA6B,IAA7B;AACAT,IAAAA,UAAU,CAACU,oBAAX,CAAgC,IAAhC,EAAsC,CAAC,MAAD,EAAS,MAAT,EAAiB,OAAjB,CAAtC;AACD;;;;+BAEW;AACV,gCAAmB,KAAKF,IAAL,CAAUG,mBAAV,EAAnB,wBAA+D,KAAKC,IAApE,uBAAoF,KAAKC,KAAzF;AACD;;;6BAES;AACR,UAAI,CAAC,KAAKC,KAAV,EAAiB;AACf,aAAKA,KAAL,GAAaC,MAAM,CAACC,MAAP,CAAc;AACzBd,UAAAA,IAAI,EAAE,KAAKU,IADc;AAEzBT,UAAAA,IAAI,EAAE,KAAKU,KAFc;AAGzBT,UAAAA,GAAG,EAAE,KAAKa,IAAL,CAAUN,mBAAV;AAHoB,SAAd,CAAb;AAKD;;AAED,aAAOI,MAAM,CAACG,MAAP,CAAc,EAAd,EAAkB,KAAKJ,KAAvB,CAAP;AACD;;;wBAEW;AACV,aAAO,KAAKT,KAAZ;AACD,K,CAED;AACA;AACA;;sBAUUH,I,EAAM;AACd,YAAM,IAAIiB,KAAJ,CAAU,yCAAV,CAAN;AACD;;;wBAXmB;AAClB,UAAI,KAAKb,QAAL,KAAkB,IAAtB,EAA4B;AAC1B,eAAO,KAAKA,QAAZ;AACD;;AAED,WAAKA,QAAL,GAAgBc,MAAM,CAACC,IAAP,CAAY,KAAKhB,KAAjB,CAAhB;AACA,aAAO,KAAKC,QAAZ;AACD;;;wBAMY;AACX,aAAO,KAAKC,KAAZ;AACD,K;sBAEUJ,I,EAAM;AACf,YAAM,IAAIgB,KAAJ,CAAU,yCAAV,CAAN;AACD;;;wBAEW;AACV,aAAO,KAAKX,IAAZ;AACD,K;sBAESJ,G,EAAK;AACb,YAAM,IAAIe,KAAJ,CAAU,wCAAV,CAAN;AACD;;;;;;AAGHG,OAAO,GAAGC,MAAM,CAACD,OAAP,GAAiBvB,MAAM,CAACE,OAAD,EAAU;AAAEuB,EAAAA,SAAS,EAAE,SAAb;AAAwBC,EAAAA,UAAU,EAAE;AAApC,CAAV,CAAjC;AACAH,OAAO,CAACI,IAAR,GAAe7B,OAAO,CAAC,QAAD,CAAtB","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst assert = require('assert')\nconst withIs = require('class-is')\nconst visibility = require('../visibility')\n\n// Link represents an IPFS Merkle DAG Link between Nodes.\nclass DAGLink {\n  constructor (name, size, cid) {\n    assert(cid, 'A link requires a cid to point to')\n    // assert(size, 'A link requires a size')\n    //  note - links should include size, but this assert is disabled\n    //  for now to maintain consistency with go-ipfs pinset\n\n    this._name = name || ''\n    this._nameBuf = null\n    this._size = size\n    this._cid = new CID(cid)\n\n    // Make sure we have a nice public API that can be used by an IPLD resolver\n    visibility.hidePrivateFields(this)\n    visibility.addEnumerableGetters(this, ['Hash', 'Name', 'Tsize'])\n  }\n\n  toString () {\n    return `DAGLink <${this._cid.toBaseEncodedString()} - name: \"${this.Name}\", size: ${this.Tsize}>`\n  }\n\n  toJSON () {\n    if (!this._json) {\n      this._json = Object.freeze({\n        name: this.Name,\n        size: this.Tsize,\n        cid: this.Hash.toBaseEncodedString()\n      })\n    }\n\n    return Object.assign({}, this._json)\n  }\n\n  get Name () {\n    return this._name\n  }\n\n  // Memoize the Buffer representation of name\n  // We need this to sort the links, otherwise\n  // we will reallocate new buffers every time\n  get nameAsBuffer () {\n    if (this._nameBuf !== null) {\n      return this._nameBuf\n    }\n\n    this._nameBuf = Buffer.from(this._name)\n    return this._nameBuf\n  }\n\n  set Name (name) {\n    throw new Error(\"Can't set property: 'name' is immutable\")\n  }\n\n  get Tsize () {\n    return this._size\n  }\n\n  set Tsize (size) {\n    throw new Error(\"Can't set property: 'size' is immutable\")\n  }\n\n  get Hash () {\n    return this._cid\n  }\n\n  set Hash (cid) {\n    throw new Error(\"Can't set property: 'cid' is immutable\")\n  }\n}\n\nexports = module.exports = withIs(DAGLink, { className: 'DAGLink', symbolName: '@ipld/js-ipld-dag-pb/daglink' })\nexports.util = require('./util')\n"]},"metadata":{},"sourceType":"script"}