{"ast":null,"code":"var pull = require('pull-stream/pull');\n\nvar looper = require('looper');\n\nfunction destroy(stream) {\n  if (!stream.destroy) console.error('warning, stream-to-pull-stream: \\n' + 'the wrapped node-stream does not implement `destroy`, \\n' + 'this may cause resource leaks.');else stream.destroy();\n}\n\nfunction write(read, stream, cb) {\n  var ended,\n      closed = false,\n      did;\n\n  function done() {\n    if (did) return;\n    did = true;\n    cb && cb(ended === true ? null : ended);\n  }\n\n  function onClose() {\n    if (closed) return;\n    closed = true;\n    cleanup();\n    if (!ended) read(ended = true, done);else done();\n  }\n\n  function onError(err) {\n    cleanup();\n    if (!ended) read(ended = err, done);\n  }\n\n  function cleanup() {\n    stream.on('finish', onClose);\n    stream.removeListener('close', onClose);\n    stream.removeListener('error', onError);\n  }\n\n  stream.on('close', onClose);\n  stream.on('finish', onClose);\n  stream.on('error', onError);\n  process.nextTick(function () {\n    looper(function (next) {\n      read(null, function (end, data) {\n        ended = ended || end; //you can't \"end\" a stdout stream, so this needs to be handled specially.\n\n        if (end === true) return stream._isStdio ? done() : stream.end();\n\n        if (ended = ended || end) {\n          destroy(stream);\n          return done(ended);\n        } //I noticed a problem streaming to the terminal:\n        //sometimes the end got cut off, creating invalid output.\n        //it seems that stdout always emits \"drain\" when it ends.\n        //so this seems to work, but i have been unable to reproduce this test\n        //automatically, so you need to run ./test/stdout.js a few times and the end is valid json.\n\n\n        if (stream._isStdio) stream.write(data, function () {\n          next();\n        });else {\n          var pause = stream.write(data);\n          if (pause === false) stream.once('drain', next);else next();\n        }\n      });\n    });\n  });\n}\n\nfunction first(emitter, events, handler) {\n  function listener(val) {\n    events.forEach(function (e) {\n      emitter.removeListener(e, listener);\n    });\n    handler(val);\n  }\n\n  events.forEach(function (e) {\n    emitter.on(e, listener);\n  });\n  return emitter;\n}\n\nfunction read2(stream) {\n  var ended = false,\n      waiting = false;\n\n  var _cb;\n\n  function read() {\n    var data = stream.read();\n\n    if (data !== null && _cb) {\n      var cb = _cb;\n      _cb = null;\n      cb(null, data);\n    }\n  }\n\n  stream.on('readable', function () {\n    waiting = true;\n    _cb && read();\n  }).on('end', function () {\n    ended = true;\n    _cb && _cb(ended);\n  }).on('error', function (err) {\n    ended = err;\n    _cb && _cb(ended);\n  });\n  return function (end, cb) {\n    _cb = cb;\n    if (ended) cb(ended);else if (waiting) read();\n  };\n}\n\nfunction read1(stream) {\n  var buffer = [],\n      cbs = [],\n      ended,\n      paused = false;\n  var draining;\n\n  function drain() {\n    while ((buffer.length || ended) && cbs.length) {\n      cbs.shift()(buffer.length ? null : ended, buffer.shift());\n    }\n\n    if (!buffer.length && paused) {\n      paused = false;\n      stream.resume();\n    }\n  }\n\n  stream.on('data', function (data) {\n    buffer.push(data);\n    drain();\n\n    if (buffer.length && stream.pause) {\n      paused = true;\n      stream.pause();\n    }\n  });\n  stream.on('end', function () {\n    ended = true;\n    drain();\n  });\n  stream.on('close', function () {\n    ended = true;\n    drain();\n  });\n  stream.on('error', function (err) {\n    ended = err;\n    drain();\n  });\n  return function (abort, cb) {\n    if (!cb) throw new Error('*must* provide cb');\n\n    if (abort) {\n      var onAbort = function onAbort() {\n        while (cbs.length) {\n          cbs.shift()(abort);\n        }\n\n        cb(abort);\n      }; //if the stream happens to have already ended, then we don't need to abort.\n\n\n      if (ended) return onAbort();\n      stream.once('close', onAbort);\n      destroy(stream);\n    } else {\n      cbs.push(cb);\n      drain();\n    }\n  };\n}\n\nvar read = read1;\n\nvar sink = function sink(stream, cb) {\n  return function (read) {\n    return write(read, stream, cb);\n  };\n};\n\nvar source = function source(stream) {\n  return read1(stream);\n};\n\nexports = module.exports = function (stream, cb) {\n  return stream.writable && stream.write ? stream.readable ? function (_read) {\n    write(_read, stream, cb);\n    return read1(stream);\n  } : sink(stream, cb) : source(stream);\n};\n\nexports.sink = sink;\nexports.source = source;\nexports.read = read;\nexports.read1 = read1;\nexports.read2 = read2;\n\nexports.duplex = function (stream, cb) {\n  return {\n    source: source(stream),\n    sink: sink(stream, cb)\n  };\n};\n\nexports.transform = function (stream) {\n  return function (read) {\n    var _source = source(stream);\n\n    sink(stream)(read);\n    return _source;\n  };\n};","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/stream-to-pull-stream/index.js"],"names":["pull","require","looper","destroy","stream","console","error","write","read","cb","ended","closed","did","done","onClose","cleanup","onError","err","on","removeListener","process","nextTick","next","end","data","_isStdio","pause","once","first","emitter","events","handler","listener","val","forEach","e","read2","waiting","_cb","read1","buffer","cbs","paused","draining","drain","length","shift","resume","push","abort","Error","onAbort","sink","source","exports","module","writable","readable","_read","duplex","transform","_source"],"mappings":"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","sourcesContent":["var pull = require('pull-stream/pull')\nvar looper = require('looper')\n\nfunction destroy (stream) {\n  if(!stream.destroy)\n    console.error(\n      'warning, stream-to-pull-stream: \\n'\n    + 'the wrapped node-stream does not implement `destroy`, \\n'\n    + 'this may cause resource leaks.'\n    )\n  else stream.destroy()\n\n}\n\nfunction write(read, stream, cb) {\n  var ended, closed = false, did\n  function done () {\n    if(did) return\n    did = true\n    cb && cb(ended === true ? null : ended)\n  }\n\n  function onClose () {\n    if(closed) return\n    closed = true\n    cleanup()\n    if(!ended) read(ended = true, done)\n    else       done()\n  }\n  function onError (err) {\n    cleanup()\n    if(!ended) read(ended = err, done)\n  }\n  function cleanup() {\n    stream.on('finish', onClose)\n    stream.removeListener('close', onClose)\n    stream.removeListener('error', onError)\n  }\n  stream.on('close', onClose)\n  stream.on('finish', onClose)\n  stream.on('error', onError)\n  process.nextTick(function () {\n    looper(function (next) {\n      read(null, function (end, data) {\n        ended = ended || end\n        //you can't \"end\" a stdout stream, so this needs to be handled specially.\n        if(end === true)\n          return stream._isStdio ? done() : stream.end()\n\n        if(ended = ended || end) {\n          destroy(stream)\n          return done(ended)\n        }\n\n        //I noticed a problem streaming to the terminal:\n        //sometimes the end got cut off, creating invalid output.\n        //it seems that stdout always emits \"drain\" when it ends.\n        //so this seems to work, but i have been unable to reproduce this test\n        //automatically, so you need to run ./test/stdout.js a few times and the end is valid json.\n        if(stream._isStdio)\n          stream.write(data, function () { next() })\n        else {\n          var pause = stream.write(data)\n          if(pause === false)\n            stream.once('drain', next)\n          else next()\n        }\n      })\n    })\n  })\n}\n\nfunction first (emitter, events, handler) {\n  function listener (val) {\n    events.forEach(function (e) {\n      emitter.removeListener(e, listener)\n    })\n    handler(val)\n  }\n  events.forEach(function (e) {\n    emitter.on(e, listener)\n  })\n  return emitter\n}\n\nfunction read2(stream) {\n  var ended = false, waiting = false\n  var _cb\n\n  function read () {\n    var data = stream.read()\n    if(data !== null && _cb) {\n      var cb = _cb; _cb = null\n      cb(null, data)\n    }\n  }\n\n  stream.on('readable', function () {\n    waiting = true\n    _cb && read()\n  })\n  .on('end', function () {\n    ended = true\n    _cb && _cb(ended)\n  })\n  .on('error', function (err) {\n    ended = err\n    _cb && _cb(ended)\n  })\n\n  return function (end, cb) {\n    _cb = cb\n    if(ended)\n      cb(ended)\n    else if(waiting)\n      read()\n  }\n}\n\nfunction read1(stream) {\n  var buffer = [], cbs = [], ended, paused = false\n\n  var draining\n  function drain() {\n    while((buffer.length || ended) && cbs.length)\n      cbs.shift()(buffer.length ? null : ended, buffer.shift())\n    if(!buffer.length && (paused)) {\n      paused = false\n      stream.resume()\n    }\n  }\n\n  stream.on('data', function (data) {\n    buffer.push(data)\n    drain()\n    if(buffer.length && stream.pause) {\n      paused = true\n      stream.pause()\n    }\n  })\n  stream.on('end', function () {\n    ended = true\n    drain()\n  })\n  stream.on('close', function () {\n    ended = true\n    drain()\n  })\n  stream.on('error', function (err) {\n    ended = err\n    drain()\n  })\n  return function (abort, cb) {\n    if(!cb) throw new Error('*must* provide cb')\n    if(abort) {\n      function onAbort () {\n        while(cbs.length) cbs.shift()(abort)\n        cb(abort)\n      }\n      //if the stream happens to have already ended, then we don't need to abort.\n      if(ended) return onAbort()\n      stream.once('close', onAbort)\n      destroy(stream)\n    }\n    else {\n      cbs.push(cb)\n      drain()\n    }\n  }\n}\n\nvar read = read1\n\nvar sink = function (stream, cb) {\n  return function (read) {\n    return write(read, stream, cb)\n  }\n}\n\nvar source = function (stream) {\n  return read1(stream)\n}\n\nexports = module.exports = function (stream, cb) {\n  return (\n    (stream.writable && stream.write)\n    ? stream.readable\n      ? function(_read) {\n          write(_read, stream, cb);\n          return read1(stream)\n        }\n      : sink(stream, cb)\n    : source(stream)\n  )\n}\n\nexports.sink = sink\nexports.source = source\nexports.read = read\nexports.read1 = read1\nexports.read2 = read2\nexports.duplex = function (stream, cb) {\n  return {\n    source: source(stream),\n    sink: sink(stream, cb)\n  }\n}\nexports.transform = function (stream) {\n  return function (read) {\n    var _source = source(stream)\n    sink(stream)(read); return _source\n  }\n}\n\n\n\n\n\n\n\n\n\n"]},"metadata":{},"sourceType":"script"}