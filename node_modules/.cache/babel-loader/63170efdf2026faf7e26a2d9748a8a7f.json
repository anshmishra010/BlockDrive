{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar assert = require('assert');\n\nvar withIs = require('class-is');\n\nvar addNamedLink = require('./addNamedLink');\n\nvar visibility = require('../visibility');\n\nvar DAGNode = /*#__PURE__*/function () {\n  function DAGNode(data, links, serializedSize) {\n    var _this = this;\n\n    _classCallCheck(this, DAGNode);\n\n    if (serializedSize !== 0) {\n      assert(serializedSize, 'A DAGNode requires it\\'s serialized size');\n    }\n\n    this._data = data || Buffer.alloc(0);\n    this._links = links;\n    this._serializedSize = serializedSize; // Make sure we have a nice public API that can be used by an IPLD resolver\n\n    visibility.hidePrivateFields(this);\n    visibility.addEnumerableGetters(this, ['Data', 'Links']); // Add getters for existing links by the name of the link\n    // This is how paths are traversed in IPFS. Links with names won't\n    // override existing fields like `data` or `links`.\n\n    links.forEach(function (link, position) {\n      addNamedLink(_this, link.Name, position);\n    });\n  }\n\n  _createClass(DAGNode, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      if (!this._json) {\n        this._json = Object.freeze({\n          data: this.Data,\n          links: this._links.map(function (l) {\n            return l.toJSON();\n          }),\n          size: this.size\n        });\n      }\n\n      return Object.assign({}, this._json);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"DAGNode <data: \\\"\".concat(this.Data.toString('base64'), \"\\\", links: \").concat(this.Links.length, \", size: \").concat(this.size, \">\");\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      if (this._size === undefined) {\n        this._size = this._links.reduce(function (sum, l) {\n          return sum + l.Tsize;\n        }, this._serializedSize);\n      }\n\n      return this._size;\n    },\n    set: function set(size) {\n      throw new Error(\"Can't set property: 'size' is immutable\");\n    } // Getters for backwards compatible path resolving\n\n  }, {\n    key: \"Data\",\n    get: function get() {\n      return this._data;\n    },\n    set: function set(_) {\n      throw new Error(\"Can't set property: 'Data' is immutable\");\n    }\n  }, {\n    key: \"Links\",\n    get: function get() {\n      return this._links.map(function (link) {\n        return {\n          Name: link.Name,\n          Tsize: link.Tsize,\n          Hash: link.Hash\n        };\n      });\n    },\n    set: function set(_) {\n      throw new Error(\"Can't set property: 'Links' is immutable\");\n    }\n  }]);\n\n  return DAGNode;\n}();\n\nexports = module.exports = withIs(DAGNode, {\n  className: 'DAGNode',\n  symbolName: '@ipld/js-ipld-dag-pb/dagnode'\n});\nexports.create = require('./create');\nexports.clone = require('./clone');\nexports.addLink = require('./addLink');\nexports.rmLink = require('./rmLink');","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/ipld-dag-pb/src/dag-node/index.js"],"names":["assert","require","withIs","addNamedLink","visibility","DAGNode","data","links","serializedSize","_data","Buffer","alloc","_links","_serializedSize","hidePrivateFields","addEnumerableGetters","forEach","link","position","Name","_json","Object","freeze","Data","map","l","toJSON","size","assign","toString","Links","length","_size","undefined","reduce","sum","Tsize","Error","_","Hash","exports","module","className","symbolName","create","clone","addLink","rmLink"],"mappings":"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","sourcesContent":["'use strict'\n\nconst assert = require('assert')\nconst withIs = require('class-is')\nconst addNamedLink = require('./addNamedLink')\nconst visibility = require('../visibility')\n\nclass DAGNode {\n  constructor (data, links, serializedSize) {\n    if (serializedSize !== 0) {\n      assert(serializedSize, 'A DAGNode requires it\\'s serialized size')\n    }\n\n    this._data = data || Buffer.alloc(0)\n    this._links = links\n    this._serializedSize = serializedSize\n\n    // Make sure we have a nice public API that can be used by an IPLD resolver\n    visibility.hidePrivateFields(this)\n    visibility.addEnumerableGetters(this, ['Data', 'Links'])\n\n    // Add getters for existing links by the name of the link\n    // This is how paths are traversed in IPFS. Links with names won't\n    // override existing fields like `data` or `links`.\n    links.forEach((link, position) => {\n      addNamedLink(this, link.Name, position)\n    })\n  }\n\n  toJSON () {\n    if (!this._json) {\n      this._json = Object.freeze({\n        data: this.Data,\n        links: this._links.map((l) => l.toJSON()),\n        size: this.size\n      })\n    }\n\n    return Object.assign({}, this._json)\n  }\n\n  toString () {\n    return `DAGNode <data: \"${this.Data.toString('base64')}\", links: ${this.Links.length}, size: ${this.size}>`\n  }\n\n  get size () {\n    if (this._size === undefined) {\n      this._size = this._links.reduce((sum, l) => sum + l.Tsize, this._serializedSize)\n    }\n\n    return this._size\n  }\n\n  set size (size) {\n    throw new Error(\"Can't set property: 'size' is immutable\")\n  }\n\n  // Getters for backwards compatible path resolving\n  get Data () {\n    return this._data\n  }\n  set Data (_) {\n    throw new Error(\"Can't set property: 'Data' is immutable\")\n  }\n  get Links () {\n    return this._links.map((link) => {\n      return {\n        Name: link.Name,\n        Tsize: link.Tsize,\n        Hash: link.Hash\n      }\n    })\n  }\n  set Links (_) {\n    throw new Error(\"Can't set property: 'Links' is immutable\")\n  }\n}\n\nexports = module.exports = withIs(DAGNode, { className: 'DAGNode', symbolName: '@ipld/js-ipld-dag-pb/dagnode' })\nexports.create = require('./create')\nexports.clone = require('./clone')\nexports.addLink = require('./addLink')\nexports.rmLink = require('./rmLink')\n"]},"metadata":{},"sourceType":"script"}