{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"C:\\\\Users\\\\anshm\\\\blockdrive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createForOfIteratorHelper\");\n\nvar Qs = require('qs');\n\nvar qsDefaultEncoder = require('qs/lib/utils').encode;\n\nvar isNode = require('detect-node');\n\nvar ndjson = require('ndjson');\n\nvar pump = require('pump');\n\nvar once = require('once');\n\nvar _require = require('iso-stream-http'),\n    getRequest = _require.getRequest;\n\nvar streamToValue = require('./stream-to-value');\n\nvar streamToJsonValue = require('./stream-to-json-value');\n\nvar log = require('debug')('ipfs-http-client:request'); // -- Internal\n\n\nfunction hasJSONHeaders(res) {\n  return res.headers['content-type'] && res.headers['content-type'].indexOf('application/json') === 0;\n}\n\nfunction parseError(res, cb) {\n  var error = new Error(\"Server responded with \".concat(res.statusCode));\n  error.statusCode = res.statusCode;\n\n  if (!hasJSONHeaders(res)) {\n    return streamToValue(res, function (err, data) {\n      // eslint-disable-line handle-callback-err\n      // the `err` here refers to errors in stream processing, which\n      // we ignore here, since we already have a valid `error` response\n      // from the server above that we have to report to the caller.\n      if (data && data.length) {\n        error.message = data.toString();\n      }\n\n      cb(error);\n    });\n  }\n\n  streamToJsonValue(res, function (err, payload) {\n    if (err) {\n      return cb(err);\n    }\n\n    if (payload) {\n      error.code = payload.Code;\n      error.message = payload.Message || payload.toString();\n      error.type = payload.Type;\n    }\n\n    cb(error);\n  });\n}\n\nfunction onRes(buffer, cb) {\n  return function (res) {\n    var stream = Boolean(res.headers['x-stream-output']);\n    var chunkedObjects = Boolean(res.headers['x-chunked-output']);\n    var isJson = hasJSONHeaders(res);\n\n    if (res.req) {\n      log(res.req.method, \"\".concat(res.req.getHeaders().host).concat(res.req.path), res.statusCode, res.statusMessage);\n    } else {\n      log(res.url, res.statusCode, res.statusMessage);\n    }\n\n    if (res.statusCode >= 400 || !res.statusCode) {\n      return parseError(res, cb);\n    } // Return the response stream directly\n\n\n    if (stream && !buffer) {\n      return cb(null, res);\n    } // Return a stream of JSON objects\n\n\n    if (chunkedObjects && isJson) {\n      var outputStream = ndjson.parse();\n      pump(res, outputStream);\n      res.on('end', function () {\n        var err = res.trailers['x-stream-error'];\n\n        if (err) {\n          // Not all errors are JSON\n          try {\n            err = JSON.parse(err);\n          } catch (e) {\n            err = {\n              Message: err\n            };\n          }\n\n          outputStream.emit('error', new Error(err.Message));\n        }\n      });\n      return cb(null, outputStream);\n    } // Return a JSON object\n\n\n    if (isJson) {\n      return streamToJsonValue(res, cb);\n    } // Return a value\n\n\n    return streamToValue(res, cb);\n  };\n}\n\nfunction requestAPI(config, options, callback) {\n  callback = once(callback);\n  options.qs = options.qs || {};\n\n  if (Array.isArray(options.path)) {\n    options.path = options.path.join('/');\n  }\n\n  if (options.args && !Array.isArray(options.args)) {\n    options.args = [options.args];\n  }\n\n  if (options.args) {\n    options.qs.arg = options.args;\n  }\n\n  if (options.progress) {\n    options.qs.progress = true;\n  }\n\n  if (options.qs.r) {\n    options.qs.recursive = options.qs.r; // From IPFS 0.4.0, it throws an error when both r and recursive are passed\n\n    delete options.qs.r;\n  }\n\n  options.qs['stream-channels'] = true;\n\n  if (options.stream) {\n    options.buffer = false;\n  } // this option is only used internally, not passed to daemon\n\n\n  delete options.qs.followSymlinks;\n  var method = 'POST';\n  var headers = Object.assign({}, config.headers);\n\n  if (isNode) {\n    // Browsers do not allow you to modify the user agent\n    headers['User-Agent'] = config['user-agent'];\n  }\n\n  if (options.multipart) {\n    if (!options.multipartBoundary) {\n      return callback(new Error('No multipartBoundary'));\n    }\n\n    headers['Content-Type'] = \"multipart/form-data; boundary=\".concat(options.multipartBoundary);\n  }\n\n  var qs = Qs.stringify(options.qs, {\n    arrayFormat: 'repeat',\n    encoder: function encoder(data) {\n      // TODO: future releases of qs will provide the default\n      // encoder as a 2nd argument to this function; it will\n      // no longer be necessary to import qsDefaultEncoder\n      if (Buffer.isBuffer(data)) {\n        var uriEncoded = '';\n\n        var _iterator = _createForOfIteratorHelper(data),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var byte = _step.value;\n\n            // https://tools.ietf.org/html/rfc3986#page-14\n            // ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E), underscore (%5F), or tilde (%7E)\n            if (byte >= 0x41 && byte <= 0x5A || byte >= 0x61 && byte <= 0x7A || byte >= 0x30 && byte <= 0x39 || byte === 0x2D || byte === 0x2E || byte === 0x5F || byte === 0x7E) {\n              uriEncoded += String.fromCharCode(byte);\n            } else {\n              var hex = byte.toString(16); // String.prototype.padStart() not widely supported yet\n\n              var padded = hex.length === 1 ? \"0\".concat(hex) : hex;\n              uriEncoded += \"%\".concat(padded);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return uriEncoded;\n      }\n\n      return qsDefaultEncoder(data);\n    }\n  });\n  var reqOptions = {\n    hostname: config.host,\n    path: \"\".concat(config['api-path']).concat(options.path, \"?\").concat(qs),\n    port: config.port,\n    method: method,\n    headers: headers,\n    protocol: \"\".concat(config.protocol, \":\")\n  };\n  var req = getRequest(reqOptions, onRes(options.buffer, callback));\n  req.on('error', function (err) {\n    callback(err);\n  });\n\n  if (!options.stream) {\n    req.end();\n  }\n\n  return req;\n} //\n// -- Module Interface\n\n\nexports = module.exports = function (config) {\n  /*\n   * options: {\n   *   path:   // API path (like /add or /config) - type: string\n   *   args:   // Arguments to the command - type: object\n   *   qs:     // Opts as query string opts to the command --something - type: object\n   *   files:  // files to be sent - type: string, buffer or array of strings or buffers\n   *   buffer: // buffer the request before sending it - type: bool\n   * }\n   */\n  var send = function send(options, callback) {\n    if (typeof options !== 'object') {\n      return callback(new Error('no options were passed'));\n    }\n\n    return requestAPI(config, options, callback);\n  }; // Send a HTTP request and pass via a transform function\n  // to convert the response data to wanted format before\n  // returning it to the callback.\n  // Eg. send.andTransform({}, (e) => JSON.parse(e), (err, res) => ...)\n\n\n  send.andTransform = function (options, transform, callback) {\n    return send(options, function (err, res) {\n      if (err) {\n        return callback(err);\n      }\n\n      transform(res, callback);\n    });\n  };\n\n  return send;\n};","map":{"version":3,"sources":["C:/Users/anshm/blockdrive/node_modules/ipfs-http-client/src/utils/send-request.js"],"names":["Qs","require","qsDefaultEncoder","encode","isNode","ndjson","pump","once","getRequest","streamToValue","streamToJsonValue","log","hasJSONHeaders","res","headers","indexOf","parseError","cb","error","Error","statusCode","err","data","length","message","toString","payload","code","Code","Message","type","Type","onRes","buffer","stream","Boolean","chunkedObjects","isJson","req","method","getHeaders","host","path","statusMessage","url","outputStream","parse","on","trailers","JSON","e","emit","requestAPI","config","options","callback","qs","Array","isArray","join","args","arg","progress","r","recursive","followSymlinks","Object","assign","multipart","multipartBoundary","stringify","arrayFormat","encoder","Buffer","isBuffer","uriEncoded","byte","String","fromCharCode","hex","padded","reqOptions","hostname","port","protocol","end","exports","module","send","andTransform","transform"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Qs = require('qs')\nconst qsDefaultEncoder = require('qs/lib/utils').encode\nconst isNode = require('detect-node')\nconst ndjson = require('ndjson')\nconst pump = require('pump')\nconst once = require('once')\nconst { getRequest } = require('iso-stream-http')\nconst streamToValue = require('./stream-to-value')\nconst streamToJsonValue = require('./stream-to-json-value')\nconst log = require('debug')('ipfs-http-client:request')\n\n// -- Internal\n\nfunction hasJSONHeaders (res) {\n  return res.headers['content-type'] &&\n    res.headers['content-type'].indexOf('application/json') === 0\n}\n\nfunction parseError (res, cb) {\n  const error = new Error(`Server responded with ${res.statusCode}`)\n  error.statusCode = res.statusCode\n\n  if (!hasJSONHeaders(res)) {\n    return streamToValue(res, (err, data) => { // eslint-disable-line handle-callback-err\n      // the `err` here refers to errors in stream processing, which\n      // we ignore here, since we already have a valid `error` response\n      // from the server above that we have to report to the caller.\n      if (data && data.length) {\n        error.message = data.toString()\n      }\n      cb(error)\n    })\n  }\n\n  streamToJsonValue(res, (err, payload) => {\n    if (err) {\n      return cb(err)\n    }\n\n    if (payload) {\n      error.code = payload.Code\n      error.message = payload.Message || payload.toString()\n      error.type = payload.Type\n    }\n    cb(error)\n  })\n}\n\nfunction onRes (buffer, cb) {\n  return (res) => {\n    const stream = Boolean(res.headers['x-stream-output'])\n    const chunkedObjects = Boolean(res.headers['x-chunked-output'])\n    const isJson = hasJSONHeaders(res)\n\n    if (res.req) {\n      log(res.req.method, `${res.req.getHeaders().host}${res.req.path}`, res.statusCode, res.statusMessage)\n    } else {\n      log(res.url, res.statusCode, res.statusMessage)\n    }\n\n    if (res.statusCode >= 400 || !res.statusCode) {\n      return parseError(res, cb)\n    }\n\n    // Return the response stream directly\n    if (stream && !buffer) {\n      return cb(null, res)\n    }\n\n    // Return a stream of JSON objects\n    if (chunkedObjects && isJson) {\n      const outputStream = ndjson.parse()\n      pump(res, outputStream)\n      res.on('end', () => {\n        let err = res.trailers['x-stream-error']\n        if (err) {\n          // Not all errors are JSON\n          try {\n            err = JSON.parse(err)\n          } catch (e) {\n            err = { Message: err }\n          }\n          outputStream.emit('error', new Error(err.Message))\n        }\n      })\n      return cb(null, outputStream)\n    }\n\n    // Return a JSON object\n    if (isJson) {\n      return streamToJsonValue(res, cb)\n    }\n\n    // Return a value\n    return streamToValue(res, cb)\n  }\n}\n\nfunction requestAPI (config, options, callback) {\n  callback = once(callback)\n  options.qs = options.qs || {}\n\n  if (Array.isArray(options.path)) {\n    options.path = options.path.join('/')\n  }\n  if (options.args && !Array.isArray(options.args)) {\n    options.args = [options.args]\n  }\n  if (options.args) {\n    options.qs.arg = options.args\n  }\n  if (options.progress) {\n    options.qs.progress = true\n  }\n\n  if (options.qs.r) {\n    options.qs.recursive = options.qs.r\n    // From IPFS 0.4.0, it throws an error when both r and recursive are passed\n    delete options.qs.r\n  }\n\n  options.qs['stream-channels'] = true\n\n  if (options.stream) {\n    options.buffer = false\n  }\n\n  // this option is only used internally, not passed to daemon\n  delete options.qs.followSymlinks\n\n  const method = 'POST'\n  const headers = Object.assign({}, config.headers)\n\n  if (isNode) {\n    // Browsers do not allow you to modify the user agent\n    headers['User-Agent'] = config['user-agent']\n  }\n\n  if (options.multipart) {\n    if (!options.multipartBoundary) {\n      return callback(new Error('No multipartBoundary'))\n    }\n\n    headers['Content-Type'] = `multipart/form-data; boundary=${options.multipartBoundary}`\n  }\n\n  const qs = Qs.stringify(options.qs, {\n    arrayFormat: 'repeat',\n    encoder: data => {\n      // TODO: future releases of qs will provide the default\n      // encoder as a 2nd argument to this function; it will\n      // no longer be necessary to import qsDefaultEncoder\n      if (Buffer.isBuffer(data)) {\n        let uriEncoded = ''\n        for (const byte of data) {\n          // https://tools.ietf.org/html/rfc3986#page-14\n          // ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E), underscore (%5F), or tilde (%7E)\n          if (\n            (byte >= 0x41 && byte <= 0x5A) ||\n            (byte >= 0x61 && byte <= 0x7A) ||\n            (byte >= 0x30 && byte <= 0x39) ||\n            (byte === 0x2D) ||\n            (byte === 0x2E) ||\n            (byte === 0x5F) ||\n            (byte === 0x7E)\n          ) {\n            uriEncoded += String.fromCharCode(byte)\n          } else {\n            const hex = byte.toString(16)\n            // String.prototype.padStart() not widely supported yet\n            const padded = hex.length === 1 ? `0${hex}` : hex\n            uriEncoded += `%${padded}`\n          }\n        }\n        return uriEncoded\n      }\n      return qsDefaultEncoder(data)\n    }\n  })\n  const reqOptions = {\n    hostname: config.host,\n    path: `${config['api-path']}${options.path}?${qs}`,\n    port: config.port,\n    method: method,\n    headers: headers,\n    protocol: `${config.protocol}:`\n  }\n\n  const req = getRequest(reqOptions, onRes(options.buffer, callback))\n\n  req.on('error', (err) => {\n    callback(err)\n  })\n\n  if (!options.stream) {\n    req.end()\n  }\n\n  return req\n}\n\n//\n// -- Module Interface\n\nexports = module.exports = (config) => {\n  /*\n   * options: {\n   *   path:   // API path (like /add or /config) - type: string\n   *   args:   // Arguments to the command - type: object\n   *   qs:     // Opts as query string opts to the command --something - type: object\n   *   files:  // files to be sent - type: string, buffer or array of strings or buffers\n   *   buffer: // buffer the request before sending it - type: bool\n   * }\n   */\n  const send = (options, callback) => {\n    if (typeof options !== 'object') {\n      return callback(new Error('no options were passed'))\n    }\n\n    return requestAPI(config, options, callback)\n  }\n\n  // Send a HTTP request and pass via a transform function\n  // to convert the response data to wanted format before\n  // returning it to the callback.\n  // Eg. send.andTransform({}, (e) => JSON.parse(e), (err, res) => ...)\n  send.andTransform = (options, transform, callback) => {\n    return send(options, (err, res) => {\n      if (err) {\n        return callback(err)\n      }\n      transform(res, callback)\n    })\n  }\n\n  return send\n}\n"]},"metadata":{},"sourceType":"script"}